<h1>Table of Contents<span class="tocSkip"></span></h1>
<div class="toc"><ul class="toc-item"><li><span><a href="#Python-Introduction" data-toc-modified-id="Python-Introduction-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Python Introduction</a></span><ul class="toc-item"><li><span><a href="#Math-Operators-from-Highest-to-Lowest-Precedence" data-toc-modified-id="Math-Operators-from-Highest-to-Lowest-Precedence-1.1"><span class="toc-item-num">1.1&nbsp;&nbsp;</span>Math Operators from Highest to Lowest Precedence</a></span></li><li><span><a href="#Data-type" data-toc-modified-id="Data-type-1.2"><span class="toc-item-num">1.2&nbsp;&nbsp;</span>Data type</a></span></li><li><span><a href="#Storing-Values-in-Variables" data-toc-modified-id="Storing-Values-in-Variables-1.3"><span class="toc-item-num">1.3&nbsp;&nbsp;</span>Storing Values in Variables</a></span><ul class="toc-item"><li><ul class="toc-item"><li><span><a href="#Multiple-Assignments" data-toc-modified-id="Multiple-Assignments-1.3.0.1"><span class="toc-item-num">1.3.0.1&nbsp;&nbsp;</span>Multiple Assignments</a></span></li></ul></li><li><span><a href="#Variable-Names" data-toc-modified-id="Variable-Names-1.3.1"><span class="toc-item-num">1.3.1&nbsp;&nbsp;</span>Variable Names</a></span><ul class="toc-item"><li><span><a href="#Valid-variable-names________________Invalid-variable-names" data-toc-modified-id="Valid-variable-names________________Invalid-variable-names-1.3.1.1"><span class="toc-item-num">1.3.1.1&nbsp;&nbsp;</span>Valid variable names________________Invalid variable names</a></span></li></ul></li></ul></li><li><span><a href="#First-Program" data-toc-modified-id="First-Program-1.4"><span class="toc-item-num">1.4&nbsp;&nbsp;</span>First Program</a></span></li><li><span><a href="#Comments" data-toc-modified-id="Comments-1.5"><span class="toc-item-num">1.5&nbsp;&nbsp;</span>Comments</a></span></li><li><span><a href="#The-print()-Function" data-toc-modified-id="The-print()-Function-1.6"><span class="toc-item-num">1.6&nbsp;&nbsp;</span>The print() Function</a></span></li><li><span><a href="#The-input()-Function" data-toc-modified-id="The-input()-Function-1.7"><span class="toc-item-num">1.7&nbsp;&nbsp;</span>The input() Function</a></span><ul class="toc-item"><li><span><a href="#Taking-multiple-inputs" data-toc-modified-id="Taking-multiple-inputs-1.7.1"><span class="toc-item-num">1.7.1&nbsp;&nbsp;</span>Taking multiple inputs</a></span></li></ul></li><li><span><a href="#The-len()-Function" data-toc-modified-id="The-len()-Function-1.8"><span class="toc-item-num">1.8&nbsp;&nbsp;</span>The len() Function</a></span></li><li><span><a href="#The-str(),-int(),-and-float()-Functions" data-toc-modified-id="The-str(),-int(),-and-float()-Functions-1.9"><span class="toc-item-num">1.9&nbsp;&nbsp;</span>The str(), int(), and float() Functions</a></span><ul class="toc-item"><li><ul class="toc-item"><li><span><a href="#Text-and-Number-Equivalence" data-toc-modified-id="Text-and-Number-Equivalence-1.9.0.1"><span class="toc-item-num">1.9.0.1&nbsp;&nbsp;</span>Text and Number Equivalence</a></span></li></ul></li></ul></li><li><span><a href="#Output-Formatting" data-toc-modified-id="Output-Formatting-1.10"><span class="toc-item-num">1.10&nbsp;&nbsp;</span>Output Formatting</a></span></li></ul></li><li><span><a href="#Flow-Control" data-toc-modified-id="Flow-Control-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Flow Control</a></span><ul class="toc-item"><li><ul class="toc-item"><li><ul class="toc-item"><li><span><a href="#Comparison-Operators" data-toc-modified-id="Comparison-Operators-2.0.0.1"><span class="toc-item-num">2.0.0.1&nbsp;&nbsp;</span>Comparison Operators</a></span></li></ul></li><li><span><a href="#The-Difference-Between-the-==-and-=-Op-erators" data-toc-modified-id="The-Difference-Between-the-==-and-=-Op-erators-2.0.1"><span class="toc-item-num">2.0.1&nbsp;&nbsp;</span>The Difference Between the == and = Op erators</a></span></li></ul></li><li><span><a href="#Boolean-(Logical)-Operators" data-toc-modified-id="Boolean-(Logical)-Operators-2.1"><span class="toc-item-num">2.1&nbsp;&nbsp;</span>Boolean (Logical) Operators</a></span></li><li><span><a href="#Bitwise-operators" data-toc-modified-id="Bitwise-operators-2.2"><span class="toc-item-num">2.2&nbsp;&nbsp;</span>Bitwise operators</a></span></li><li><span><a href="#Identity-Operators" data-toc-modified-id="Identity-Operators-2.3"><span class="toc-item-num">2.3&nbsp;&nbsp;</span>Identity Operators</a></span></li><li><span><a href="#MemberShip-Operators" data-toc-modified-id="MemberShip-Operators-2.4"><span class="toc-item-num">2.4&nbsp;&nbsp;</span>MemberShip Operators</a></span></li><li><span><a href="#Elements-of-Flow-Control" data-toc-modified-id="Elements-of-Flow-Control-2.5"><span class="toc-item-num">2.5&nbsp;&nbsp;</span>Elements of Flow Control</a></span><ul class="toc-item"><li><span><a href="#Conditions" data-toc-modified-id="Conditions-2.5.1"><span class="toc-item-num">2.5.1&nbsp;&nbsp;</span>Conditions</a></span></li><li><span><a href="#Blocks-of-Code" data-toc-modified-id="Blocks-of-Code-2.5.2"><span class="toc-item-num">2.5.2&nbsp;&nbsp;</span>Blocks of Code</a></span></li></ul></li><li><span><a href="#Flow-Control-Statements" data-toc-modified-id="Flow-Control-Statements-2.6"><span class="toc-item-num">2.6&nbsp;&nbsp;</span>Flow Control Statements</a></span><ul class="toc-item"><li><span><a href="#if-Statements" data-toc-modified-id="if-Statements-2.6.1"><span class="toc-item-num">2.6.1&nbsp;&nbsp;</span>if Statements</a></span></li><li><span><a href="#else-Statements" data-toc-modified-id="else-Statements-2.6.2"><span class="toc-item-num">2.6.2&nbsp;&nbsp;</span>else Statements</a></span></li><li><span><a href="#elif-Statements" data-toc-modified-id="elif-Statements-2.6.3"><span class="toc-item-num">2.6.3&nbsp;&nbsp;</span>elif Statements</a></span></li><li><span><a href="#Nested-if-Statements" data-toc-modified-id="Nested-if-Statements-2.6.4"><span class="toc-item-num">2.6.4&nbsp;&nbsp;</span>Nested if Statements</a></span></li><li><span><a href="#while-Loop-Statements" data-toc-modified-id="while-Loop-Statements-2.6.5"><span class="toc-item-num">2.6.5&nbsp;&nbsp;</span>while Loop Statements</a></span></li><li><span><a href="#while-Loop-with-else" data-toc-modified-id="while-Loop-with-else-2.6.6"><span class="toc-item-num">2.6.6&nbsp;&nbsp;</span>while Loop with else</a></span><ul class="toc-item"><li><span><a href="#Python-Program-to-check-given-number-is-Prime-number-or-not" data-toc-modified-id="Python-Program-to-check-given-number-is-Prime-number-or-not-2.6.6.1"><span class="toc-item-num">2.6.6.1&nbsp;&nbsp;</span>Python Program to check given number is Prime number or not</a></span></li></ul></li><li><span><a href="#break-Statements" data-toc-modified-id="break-Statements-2.6.7"><span class="toc-item-num">2.6.7&nbsp;&nbsp;</span>break Statements</a></span></li><li><span><a href="#continue-Statements" data-toc-modified-id="continue-Statements-2.6.8"><span class="toc-item-num">2.6.8&nbsp;&nbsp;</span>continue Statements</a></span><ul class="toc-item"><li><span><a href="#“Truthy”-and-“Fa-lsey”-Values" data-toc-modified-id="“Truthy”-and-“Fa-lsey”-Values-2.6.8.1"><span class="toc-item-num">2.6.8.1&nbsp;&nbsp;</span>“Truthy” and “Fa lsey” Values</a></span></li></ul></li><li><span><a href="#for-Loops-and-the-range()-Function" data-toc-modified-id="for-Loops-and-the-range()-Function-2.6.9"><span class="toc-item-num">2.6.9&nbsp;&nbsp;</span>for Loops and the range() Function</a></span><ul class="toc-item"><li><span><a href="#for-loop-with-else" data-toc-modified-id="for-loop-with-else-2.6.9.1"><span class="toc-item-num">2.6.9.1&nbsp;&nbsp;</span>for loop with else</a></span></li><li><span><a href="#The-Starting,-Stopping,-and-Stepping-Arguments-to-range()" data-toc-modified-id="The-Starting,-Stopping,-and-Stepping-Arguments-to-range()-2.6.9.2"><span class="toc-item-num">2.6.9.2&nbsp;&nbsp;</span>The Starting, Stopping, and Stepping Arguments to range()</a></span></li><li><span><a href="#Python-Program-to-display-all-prime-numbers-within-an-interval" data-toc-modified-id="Python-Program-to-display-all-prime-numbers-within-an-interval-2.6.9.3"><span class="toc-item-num">2.6.9.3&nbsp;&nbsp;</span>Python Program to display all prime numbers within an interval</a></span></li></ul></li><li><span><a href="#pass-Statement" data-toc-modified-id="pass-Statement-2.6.10"><span class="toc-item-num">2.6.10&nbsp;&nbsp;</span>pass Statement</a></span></li></ul></li><li><span><a href="#Importing-Modules" data-toc-modified-id="Importing-Modules-2.7"><span class="toc-item-num">2.7&nbsp;&nbsp;</span>Importing Modules</a></span></li><li><span><a href="#Ending-a-Program-Early-with-sys.exit()" data-toc-modified-id="Ending-a-Program-Early-with-sys.exit()-2.8"><span class="toc-item-num">2.8&nbsp;&nbsp;</span>Ending a Program Early with sys.exit()</a></span></li></ul></li><li><span><a href="#Functions" data-toc-modified-id="Functions-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Functions</a></span><ul class="toc-item"><li><span><a href="#def-Statements-with-Parameters" data-toc-modified-id="def-Statements-with-Parameters-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>def Statements with Parameters</a></span></li><li><span><a href="#Return-Values-and-return-Statements" data-toc-modified-id="Return-Values-and-return-Statements-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>Return Values and return Statements</a></span></li><li><span><a href="#The-None-Value" data-toc-modified-id="The-None-Value-3.3"><span class="toc-item-num">3.3&nbsp;&nbsp;</span>The None Value</a></span></li><li><span><a href="#Keyword-Arguments-and-print()" data-toc-modified-id="Keyword-Arguments-and-print()-3.4"><span class="toc-item-num">3.4&nbsp;&nbsp;</span>Keyword Arguments and print()</a></span></li><li><span><a href="#Local-and-Global-Scope" data-toc-modified-id="Local-and-Global-Scope-3.5"><span class="toc-item-num">3.5&nbsp;&nbsp;</span>Local and Global Scope</a></span><ul class="toc-item"><li><span><a href="#Local-Variables-Cannot-Be-Used-in-the-Global-Scope" data-toc-modified-id="Local-Variables-Cannot-Be-Used-in-the-Global-Scope-3.5.1"><span class="toc-item-num">3.5.1&nbsp;&nbsp;</span>Local Variables Cannot Be Used in the Global Scope</a></span></li><li><span><a href="#Local-Scopes-Cannot-Use-Variables-in-Other-Local-Scopes" data-toc-modified-id="Local-Scopes-Cannot-Use-Variables-in-Other-Local-Scopes-3.5.2"><span class="toc-item-num">3.5.2&nbsp;&nbsp;</span>Local Scopes Cannot Use Variables in Other Local Scopes</a></span></li><li><span><a href="#Global-Variables-Can-Be-Read-from-a-Local-Scope" data-toc-modified-id="Global-Variables-Can-Be-Read-from-a-Local-Scope-3.5.3"><span class="toc-item-num">3.5.3&nbsp;&nbsp;</span>Global Variables Can Be Read from a Local Scope</a></span></li><li><span><a href="#Local-and-Global-Variables-with-the-Same-Name" data-toc-modified-id="Local-and-Global-Variables-with-the-Same-Name-3.5.4"><span class="toc-item-num">3.5.4&nbsp;&nbsp;</span>Local and Global Variables with the Same Name</a></span></li></ul></li><li><span><a href="#The-global-Statement" data-toc-modified-id="The-global-Statement-3.6"><span class="toc-item-num">3.6&nbsp;&nbsp;</span>The global Statement</a></span><ul class="toc-item"><li><ul class="toc-item"><li><span><a href="#Note:" data-toc-modified-id="Note:-3.6.0.1"><span class="toc-item-num">3.6.0.1&nbsp;&nbsp;</span>Note:</a></span><ul class="toc-item"><li><span><a href="#Functions-as-“Black-Boxes”" data-toc-modified-id="Functions-as-“Black-Boxes”-3.6.0.1.1"><span class="toc-item-num">3.6.0.1.1&nbsp;&nbsp;</span>Functions as “Black Boxes”</a></span></li></ul></li></ul></li></ul></li><li><span><a href="#Exception-Handling" data-toc-modified-id="Exception-Handling-3.7"><span class="toc-item-num">3.7&nbsp;&nbsp;</span>Exception Handling</a></span></li><li><span><a href="#A-Short-Program:-Guess-the-Number" data-toc-modified-id="A-Short-Program:-Guess-the-Number-3.8"><span class="toc-item-num">3.8&nbsp;&nbsp;</span>A Short Program: Guess the Number</a></span></li><li><span><a href="#lambda-function" data-toc-modified-id="lambda-function-3.9"><span class="toc-item-num">3.9&nbsp;&nbsp;</span>lambda function</a></span></li><li><span><a href="#Summary" data-toc-modified-id="Summary-3.10"><span class="toc-item-num">3.10&nbsp;&nbsp;</span>Summary</a></span></li><li><span><a href="#Practice-Projects" data-toc-modified-id="Practice-Projects-3.11"><span class="toc-item-num">3.11&nbsp;&nbsp;</span>Practice Projects</a></span><ul class="toc-item"><li><span><a href="#The-Collatz-Sequence" data-toc-modified-id="The-Collatz-Sequence-3.11.1"><span class="toc-item-num">3.11.1&nbsp;&nbsp;</span>The Collatz Sequence</a></span></li><li><span><a href="#Input-Validation" data-toc-modified-id="Input-Validation-3.11.2"><span class="toc-item-num">3.11.2&nbsp;&nbsp;</span>Input Validation</a></span></li></ul></li></ul></li><li><span><a href="#LISTS" data-toc-modified-id="LISTS-4"><span class="toc-item-num">4&nbsp;&nbsp;</span>LISTS</a></span><ul class="toc-item"><li><ul class="toc-item"><li><span><a href="#Getting-Individual-Values-in-a-List-with-Indexes" data-toc-modified-id="Getting-Individual-Values-in-a-List-with-Indexes-4.0.1"><span class="toc-item-num">4.0.1&nbsp;&nbsp;</span>Getting Individual Values in a List with Indexes</a></span></li><li><span><a href="#Negative-Indexes" data-toc-modified-id="Negative-Indexes-4.0.2"><span class="toc-item-num">4.0.2&nbsp;&nbsp;</span>Negative Indexes</a></span></li><li><span><a href="#Getting-Sublists-with-Slices" data-toc-modified-id="Getting-Sublists-with-Slices-4.0.3"><span class="toc-item-num">4.0.3&nbsp;&nbsp;</span>Getting Sublists with Slices</a></span></li><li><span><a href="#Getting-a-List’s-Length-with-len()" data-toc-modified-id="Getting-a-List’s-Length-with-len()-4.0.4"><span class="toc-item-num">4.0.4&nbsp;&nbsp;</span>Getting a List’s Length with len()</a></span></li><li><span><a href="#List-Count" data-toc-modified-id="List-Count-4.0.5"><span class="toc-item-num">4.0.5&nbsp;&nbsp;</span>List Count</a></span></li><li><span><a href="#Changing-Values-in-a-List-with-Indexes" data-toc-modified-id="Changing-Values-in-a-List-with-Indexes-4.0.6"><span class="toc-item-num">4.0.6&nbsp;&nbsp;</span>Changing Values in a List with Indexes</a></span></li><li><span><a href="#List-Concatenation-and-List-Replication" data-toc-modified-id="List-Concatenation-and-List-Replication-4.0.7"><span class="toc-item-num">4.0.7&nbsp;&nbsp;</span>List Concatenation and List Replication</a></span></li><li><span><a href="#Removing-Values-from-Lists-with-del-Statements" data-toc-modified-id="Removing-Values-from-Lists-with-del-Statements-4.0.8"><span class="toc-item-num">4.0.8&nbsp;&nbsp;</span>Removing Values from Lists with del Statements</a></span></li></ul></li><li><span><a href="#Working-with-Lists" data-toc-modified-id="Working-with-Lists-4.1"><span class="toc-item-num">4.1&nbsp;&nbsp;</span>Working with Lists</a></span><ul class="toc-item"><li><span><a href="#Using-for-Loops-with-Lists" data-toc-modified-id="Using-for-Loops-with-Lists-4.1.1"><span class="toc-item-num">4.1.1&nbsp;&nbsp;</span>Using for Loops with Lists</a></span></li></ul></li><li><span><a href="#List-comprehension" data-toc-modified-id="List-comprehension-4.2"><span class="toc-item-num">4.2&nbsp;&nbsp;</span>List comprehension</a></span></li><li><span><a href="#Nested-List-Comprehensions" data-toc-modified-id="Nested-List-Comprehensions-4.3"><span class="toc-item-num">4.3&nbsp;&nbsp;</span>Nested List Comprehensions</a></span><ul class="toc-item"><li><span><a href="#The-in-and-not-in-Operators" data-toc-modified-id="The-in-and-not-in-Operators-4.3.1"><span class="toc-item-num">4.3.1&nbsp;&nbsp;</span>The in and not in Operators</a></span></li></ul></li><li><span><a href="#Augmented-Assignment-Operators" data-toc-modified-id="Augmented-Assignment-Operators-4.4"><span class="toc-item-num">4.4&nbsp;&nbsp;</span>Augmented Assignment Operators</a></span></li><li><span><a href="#Methods" data-toc-modified-id="Methods-4.5"><span class="toc-item-num">4.5&nbsp;&nbsp;</span>Methods</a></span><ul class="toc-item"><li><span><a href="#Finding-a-Value-in-a-List-with-the-index()-Method" data-toc-modified-id="Finding-a-Value-in-a-List-with-the-index()-Method-4.5.1"><span class="toc-item-num">4.5.1&nbsp;&nbsp;</span>Finding a Value in a List with the <em>index()</em> Method</a></span></li><li><span><a href="#Adding-Values-to-Lists-with-the-append(),extend()--and-insert()-Methods" data-toc-modified-id="Adding-Values-to-Lists-with-the-append(),extend()--and-insert()-Methods-4.5.2"><span class="toc-item-num">4.5.2&nbsp;&nbsp;</span>Adding Values to Lists with the <em>append()</em>,<em>extend()</em>  and <em>insert()</em> Methods</a></span></li><li><span><a href="#Removing-Values-from-Lists-with-remove(),-del,-pop()" data-toc-modified-id="Removing-Values-from-Lists-with-remove(),-del,-pop()-4.5.3"><span class="toc-item-num">4.5.3&nbsp;&nbsp;</span>Removing Values from Lists with remove(), del, pop()</a></span></li><li><span><a href="#List-reverse" data-toc-modified-id="List-reverse-4.5.4"><span class="toc-item-num">4.5.4&nbsp;&nbsp;</span>List reverse</a></span></li><li><span><a href="#List-related-keywords-in-Python" data-toc-modified-id="List-related-keywords-in-Python-4.5.5"><span class="toc-item-num">4.5.5&nbsp;&nbsp;</span>List related keywords in Python</a></span></li><li><span><a href="#Sorting-the-Values-in-a-List-with-the-sort()-Method-and-sorted(list)-method" data-toc-modified-id="Sorting-the-Values-in-a-List-with-the-sort()-Method-and-sorted(list)-method-4.5.6"><span class="toc-item-num">4.5.6&nbsp;&nbsp;</span>Sorting the Values in a List with the sort() Method and sorted(list) method</a></span></li></ul></li><li><span><a href="#Example-Program:-Magic-8-Ball-with-a-List" data-toc-modified-id="Example-Program:-Magic-8-Ball-with-a-List-4.6"><span class="toc-item-num">4.6&nbsp;&nbsp;</span>Example Program: Magic 8 Ball with a List</a></span></li><li><span><a href="#List-like-Types:-Strings-and-Tuples" data-toc-modified-id="List-like-Types:-Strings-and-Tuples-4.7"><span class="toc-item-num">4.7&nbsp;&nbsp;</span>List-like Types: Strings and Tuples</a></span></li><li><span><a href="#Mutable-and-Immutable-Data-Types" data-toc-modified-id="Mutable-and-Immutable-Data-Types-4.8"><span class="toc-item-num">4.8&nbsp;&nbsp;</span>Mutable and Immutable Data Types</a></span></li><li><span><a href="#The-Tuple-Data-Type" data-toc-modified-id="The-Tuple-Data-Type-4.9"><span class="toc-item-num">4.9&nbsp;&nbsp;</span>The Tuple Data Type</a></span></li><li><span><a href="#Tuple-Deletion" data-toc-modified-id="Tuple-Deletion-4.10"><span class="toc-item-num">4.10&nbsp;&nbsp;</span>Tuple Deletion</a></span></li><li><span><a href="#Tuple-Count" data-toc-modified-id="Tuple-Count-4.11"><span class="toc-item-num">4.11&nbsp;&nbsp;</span>Tuple Count</a></span></li><li><span><a href="#Tuple-Index" data-toc-modified-id="Tuple-Index-4.12"><span class="toc-item-num">4.12&nbsp;&nbsp;</span>Tuple Index</a></span></li><li><span><a href="#Tuple-Memebership" data-toc-modified-id="Tuple-Memebership-4.13"><span class="toc-item-num">4.13&nbsp;&nbsp;</span>Tuple Memebership</a></span></li><li><span><a href="#Built-in-Functions" data-toc-modified-id="Built-in-Functions-4.14"><span class="toc-item-num">4.14&nbsp;&nbsp;</span>Built in Functions</a></span><ul class="toc-item"><li><span><a href="#Tuple-Length" data-toc-modified-id="Tuple-Length-4.14.1"><span class="toc-item-num">4.14.1&nbsp;&nbsp;</span>Tuple Length</a></span></li><li><span><a href="#Tuple-Sort" data-toc-modified-id="Tuple-Sort-4.14.2"><span class="toc-item-num">4.14.2&nbsp;&nbsp;</span>Tuple Sort</a></span></li><li><span><a href="#largest-and-smallest-element" data-toc-modified-id="largest-and-smallest-element-4.14.3"><span class="toc-item-num">4.14.3&nbsp;&nbsp;</span>largest and smallest element</a></span></li><li><span><a href="#sum-of-elments" data-toc-modified-id="sum-of-elments-4.14.4"><span class="toc-item-num">4.14.4&nbsp;&nbsp;</span>sum of elments</a></span></li></ul></li><li><span><a href="#Converting-Types-with-the-list()-and-tuple()-Functions" data-toc-modified-id="Converting-Types-with-the-list()-and-tuple()-Functions-4.15"><span class="toc-item-num">4.15&nbsp;&nbsp;</span>Converting Types with the list() and tuple() Functions</a></span></li><li><span><a href="#References" data-toc-modified-id="References-4.16"><span class="toc-item-num">4.16&nbsp;&nbsp;</span>References</a></span><ul class="toc-item"><li><span><a href="#Passing-References" data-toc-modified-id="Passing-References-4.16.1"><span class="toc-item-num">4.16.1&nbsp;&nbsp;</span>Passing References</a></span></li><li><span><a href="#The-copy-Module’s-copy()-and-deepcopy()-Functions" data-toc-modified-id="The-copy-Module’s-copy()-and-deepcopy()-Functions-4.16.2"><span class="toc-item-num">4.16.2&nbsp;&nbsp;</span>The <em>copy</em> Module’s <em>copy()</em> and <em>deepcopy()</em> Functions</a></span></li></ul></li><li><span><a href="#Summary" data-toc-modified-id="Summary-4.17"><span class="toc-item-num">4.17&nbsp;&nbsp;</span>Summary</a></span></li><li><span><a href="#Practice-Projects" data-toc-modified-id="Practice-Projects-4.18"><span class="toc-item-num">4.18&nbsp;&nbsp;</span>Practice Projects</a></span><ul class="toc-item"><li><span><a href="#Comma-Code" data-toc-modified-id="Comma-Code-4.18.1"><span class="toc-item-num">4.18.1&nbsp;&nbsp;</span>Comma Code</a></span></li><li><span><a href="#Character-Picture-Grid" data-toc-modified-id="Character-Picture-Grid-4.18.2"><span class="toc-item-num">4.18.2&nbsp;&nbsp;</span>Character Picture Grid</a></span></li></ul></li></ul></li><li><span><a href="#Sets" data-toc-modified-id="Sets-5"><span class="toc-item-num">5&nbsp;&nbsp;</span>Sets</a></span><ul class="toc-item"><li><span><a href="#Set-Creation" data-toc-modified-id="Set-Creation-5.1"><span class="toc-item-num">5.1&nbsp;&nbsp;</span>Set Creation</a></span></li><li><span><a href="#Add-element-to-a-Set" data-toc-modified-id="Add-element-to-a-Set-5.2"><span class="toc-item-num">5.2&nbsp;&nbsp;</span>Add element to a Set</a></span></li><li><span><a href="#Remove-elements-from-a-Set" data-toc-modified-id="Remove-elements-from-a-Set-5.3"><span class="toc-item-num">5.3&nbsp;&nbsp;</span>Remove elements from a Set</a></span></li><li><span><a href="#Python-Set-Operations" data-toc-modified-id="Python-Set-Operations-5.4"><span class="toc-item-num">5.4&nbsp;&nbsp;</span>Python Set Operations</a></span></li><li><span><a href="#Frozen-Sets" data-toc-modified-id="Frozen-Sets-5.5"><span class="toc-item-num">5.5&nbsp;&nbsp;</span>Frozen Sets</a></span></li></ul></li><li><span><a href="#Dictionaries-and-Structuring-Data" data-toc-modified-id="Dictionaries-and-Structuring-Data-6"><span class="toc-item-num">6&nbsp;&nbsp;</span>Dictionaries and Structuring Data</a></span><ul class="toc-item"><li><span><a href="#The-Dictionary-Data-Type" data-toc-modified-id="The-Dictionary-Data-Type-6.1"><span class="toc-item-num">6.1&nbsp;&nbsp;</span>The Dictionary Data Type</a></span><ul class="toc-item"><li><span><a href="#Dictionaries-vs.-Lists" data-toc-modified-id="Dictionaries-vs.-Lists-6.1.1"><span class="toc-item-num">6.1.1&nbsp;&nbsp;</span>Dictionaries vs. Lists</a></span></li><li><span><a href="#The-keys(),-values(),-and-items()-Methods" data-toc-modified-id="The-keys(),-values(),-and-items()-Methods-6.1.2"><span class="toc-item-num">6.1.2&nbsp;&nbsp;</span>The <em>keys(), values()</em>, and <em>items()</em> Methods</a></span></li><li><span><a href="#Checking-Whether-a-Key-or-Value-Exists-in-a-Dictionary" data-toc-modified-id="Checking-Whether-a-Key-or-Value-Exists-in-a-Dictionary-6.1.3"><span class="toc-item-num">6.1.3&nbsp;&nbsp;</span>Checking Whether a <em>Key</em> or <em>Value</em> Exists in a Dictionary</a></span></li><li><span><a href="#The-get()-Method" data-toc-modified-id="The-get()-Method-6.1.4"><span class="toc-item-num">6.1.4&nbsp;&nbsp;</span>The get() Method</a></span></li><li><span><a href="#The-setdefault()-Method" data-toc-modified-id="The-setdefault()-Method-6.1.5"><span class="toc-item-num">6.1.5&nbsp;&nbsp;</span>The setdefault() Method</a></span></li></ul></li><li><span><a href="#Dict-Add-or-Modify-Elements" data-toc-modified-id="Dict-Add-or-Modify-Elements-6.2"><span class="toc-item-num">6.2&nbsp;&nbsp;</span>Dict Add or Modify Elements</a></span></li><li><span><a href="#Dict-Delete-or-Remove-Element" data-toc-modified-id="Dict-Delete-or-Remove-Element-6.3"><span class="toc-item-num">6.3&nbsp;&nbsp;</span>Dict Delete or Remove Element</a></span></li><li><span><a href="#Dictionary-Methods" data-toc-modified-id="Dictionary-Methods-6.4"><span class="toc-item-num">6.4&nbsp;&nbsp;</span>Dictionary Methods</a></span></li><li><span><a href="#Dict-Comprehension" data-toc-modified-id="Dict-Comprehension-6.5"><span class="toc-item-num">6.5&nbsp;&nbsp;</span>Dict Comprehension</a></span></li><li><span><a href="#Pretty-Printing" data-toc-modified-id="Pretty-Printing-6.6"><span class="toc-item-num">6.6&nbsp;&nbsp;</span>Pretty Printing</a></span></li><li><span><a href="#Using-Data-Structures-to-Model-Real-World-Things" data-toc-modified-id="Using-Data-Structures-to-Model-Real-World-Things-6.7"><span class="toc-item-num">6.7&nbsp;&nbsp;</span>Using Data Structures to Model Real-World Things</a></span><ul class="toc-item"><li><span><a href="#A-Tic-Tac-Toe-Board" data-toc-modified-id="A-Tic-Tac-Toe-Board-6.7.1"><span class="toc-item-num">6.7.1&nbsp;&nbsp;</span>A Tic-Tac-Toe Board</a></span><ul class="toc-item"><li><span><a href="#Complete--tic-tac-toe-game" data-toc-modified-id="Complete--tic-tac-toe-game-6.7.1.1"><span class="toc-item-num">6.7.1.1&nbsp;&nbsp;</span>Complete  tic-tac-toe game</a></span></li></ul></li><li><span><a href="#Nested-Dictionaries-and-Lists" data-toc-modified-id="Nested-Dictionaries-and-Lists-6.7.2"><span class="toc-item-num">6.7.2&nbsp;&nbsp;</span>Nested Dictionaries and Lists</a></span></li></ul></li><li><span><a href="#Summary" data-toc-modified-id="Summary-6.8"><span class="toc-item-num">6.8&nbsp;&nbsp;</span>Summary</a></span></li><li><span><a href="#Practice-Projects" data-toc-modified-id="Practice-Projects-6.9"><span class="toc-item-num">6.9&nbsp;&nbsp;</span>Practice Projects</a></span><ul class="toc-item"><li><span><a href="#Fantasy-Game-Inventory" data-toc-modified-id="Fantasy-Game-Inventory-6.9.1"><span class="toc-item-num">6.9.1&nbsp;&nbsp;</span>Fantasy Game Inventory</a></span></li><li><span><a href="#List-to-Dictionary-Function-for-Fantasy-Game-Inventory" data-toc-modified-id="List-to-Dictionary-Function-for-Fantasy-Game-Inventory-6.9.2"><span class="toc-item-num">6.9.2&nbsp;&nbsp;</span>List to Dictionary Function for Fantasy Game Inventory</a></span></li></ul></li></ul></li><li><span><a href="#Arrays" data-toc-modified-id="Arrays-7"><span class="toc-item-num">7&nbsp;&nbsp;</span>Arrays</a></span><ul class="toc-item"><li><span><a href="#creating-an-array-of-different-data-types" data-toc-modified-id="creating-an-array-of-different-data-types-7.1"><span class="toc-item-num">7.1&nbsp;&nbsp;</span>creating an array of different data types</a></span></li><li><span><a href="#Adding-elements-in-array" data-toc-modified-id="Adding-elements-in-array-7.2"><span class="toc-item-num">7.2&nbsp;&nbsp;</span>Adding elements in array</a></span></li><li><span><a href="#Removing-Elements-from-array" data-toc-modified-id="Removing-Elements-from-array-7.3"><span class="toc-item-num">7.3&nbsp;&nbsp;</span>Removing Elements from array</a></span></li><li><span><a href="#Slicing-of-a-Array" data-toc-modified-id="Slicing-of-a-Array-7.4"><span class="toc-item-num">7.4&nbsp;&nbsp;</span>Slicing of a Array</a></span></li><li><span><a href="#Searching-element-in-a-Array" data-toc-modified-id="Searching-element-in-a-Array-7.5"><span class="toc-item-num">7.5&nbsp;&nbsp;</span>Searching element in a Array</a></span></li><li><span><a href="#Updating-Elements-in-a-Array" data-toc-modified-id="Updating-Elements-in-a-Array-7.6"><span class="toc-item-num">7.6&nbsp;&nbsp;</span>Updating Elements in a Array</a></span></li></ul></li><li><span><a href="#Manipulating-Strings" data-toc-modified-id="Manipulating-Strings-8"><span class="toc-item-num">8&nbsp;&nbsp;</span>Manipulating Strings</a></span><ul class="toc-item"><li><span><a href="#Working-with-Strings" data-toc-modified-id="Working-with-Strings-8.1"><span class="toc-item-num">8.1&nbsp;&nbsp;</span>Working with Strings</a></span><ul class="toc-item"><li><span><a href="#String-Literals" data-toc-modified-id="String-Literals-8.1.1"><span class="toc-item-num">8.1.1&nbsp;&nbsp;</span>String Literals</a></span></li><li><span><a href="#Escape-Characters" data-toc-modified-id="Escape-Characters-8.1.2"><span class="toc-item-num">8.1.2&nbsp;&nbsp;</span>Escape Characters</a></span></li><li><span><a href="#Raw-Strings" data-toc-modified-id="Raw-Strings-8.1.3"><span class="toc-item-num">8.1.3&nbsp;&nbsp;</span>Raw Strings</a></span></li><li><span><a href="#Multiline-Strings-with-Triple-Quotes" data-toc-modified-id="Multiline-Strings-with-Triple-Quotes-8.1.4"><span class="toc-item-num">8.1.4&nbsp;&nbsp;</span>Multiline Strings with Triple Quotes</a></span></li><li><span><a href="#Multiline-Comments" data-toc-modified-id="Multiline-Comments-8.1.5"><span class="toc-item-num">8.1.5&nbsp;&nbsp;</span>Multiline Comments</a></span></li><li><span><a href="#Indexing-and-Slicing-Strings" data-toc-modified-id="Indexing-and-Slicing-Strings-8.1.6"><span class="toc-item-num">8.1.6&nbsp;&nbsp;</span>Indexing and Slicing Strings</a></span></li><li><span><a href="#How-to-change-or-delete-a-string-?" data-toc-modified-id="How-to-change-or-delete-a-string-?-8.1.7"><span class="toc-item-num">8.1.7&nbsp;&nbsp;</span>How to change or delete a string ?</a></span></li><li><span><a href="#Concatenation" data-toc-modified-id="Concatenation-8.1.8"><span class="toc-item-num">8.1.8&nbsp;&nbsp;</span>Concatenation</a></span></li><li><span><a href="#Iterating-Through-String" data-toc-modified-id="Iterating-Through-String-8.1.9"><span class="toc-item-num">8.1.9&nbsp;&nbsp;</span>Iterating Through String</a></span></li><li><span><a href="#The-in-and-not-in-Operators-with-Strings" data-toc-modified-id="The-in-and-not-in-Operators-with-Strings-8.1.10"><span class="toc-item-num">8.1.10&nbsp;&nbsp;</span>The in and not in Operators with Strings</a></span></li></ul></li><li><span><a href="#Useful-String-Methods" data-toc-modified-id="Useful-String-Methods-8.2"><span class="toc-item-num">8.2&nbsp;&nbsp;</span>Useful String Methods</a></span><ul class="toc-item"><li><span><a href="#The-upper(),-lower(),-isupper(),-and-islower()-String-Methods" data-toc-modified-id="The-upper(),-lower(),-isupper(),-and-islower()-String-Methods-8.2.1"><span class="toc-item-num">8.2.1&nbsp;&nbsp;</span>The upper(), lower(), isupper(), and islower() String Methods</a></span></li><li><span><a href="#find(),-replace()-methods" data-toc-modified-id="find(),-replace()-methods-8.2.2"><span class="toc-item-num">8.2.2&nbsp;&nbsp;</span>find(), replace() methods</a></span><ul class="toc-item"><li><span><a href="#Python-Program-to-Check-where-a-String-is-Palindrome-or-not-?" data-toc-modified-id="Python-Program-to-Check-where-a-String-is-Palindrome-or-not-?-8.2.2.1"><span class="toc-item-num">8.2.2.1&nbsp;&nbsp;</span>Python Program to Check where a String is Palindrome or not ?</a></span></li><li><span><a href="#Python-Program-to-Sort-Words-in-Alphabetic-Order?" data-toc-modified-id="Python-Program-to-Sort-Words-in-Alphabetic-Order?-8.2.2.2"><span class="toc-item-num">8.2.2.2&nbsp;&nbsp;</span>Python Program to Sort Words in Alphabetic Order?</a></span></li></ul></li><li><span><a href="#The-isX-String-Methods" data-toc-modified-id="The-isX-String-Methods-8.2.3"><span class="toc-item-num">8.2.3&nbsp;&nbsp;</span>The isX String Methods</a></span></li><li><span><a href="#The-join()-and-split()-String-Methods" data-toc-modified-id="The-join()-and-split()-String-Methods-8.2.4"><span class="toc-item-num">8.2.4&nbsp;&nbsp;</span>The <em>join()</em> and <em>split()</em> String Methods</a></span></li><li><span><a href="#Justifying-Text-with-rjust(),-ljust(),-and-center()" data-toc-modified-id="Justifying-Text-with-rjust(),-ljust(),-and-center()-8.2.5"><span class="toc-item-num">8.2.5&nbsp;&nbsp;</span>Justifying Text with <em>rjust()</em>, <em>ljust()</em>, and <em>center()</em></a></span></li><li><span><a href="#Removing-Whitespace-with-strip(),-rstrip(),-and-lstrip()" data-toc-modified-id="Removing-Whitespace-with-strip(),-rstrip(),-and-lstrip()-8.2.6"><span class="toc-item-num">8.2.6&nbsp;&nbsp;</span>Removing Whitespace with <em>strip()</em>, <em>rstrip()</em>, and <em>lstrip()</em></a></span></li><li><span><a href="#Copying-and-Pasting-Strings-with-the-pyperclip-Module" data-toc-modified-id="Copying-and-Pasting-Strings-with-the-pyperclip-Module-8.2.7"><span class="toc-item-num">8.2.7&nbsp;&nbsp;</span>Copying and Pasting Strings with the pyperclip Module</a></span></li></ul></li><li><span><a href="#Project:-Password-Locker" data-toc-modified-id="Project:-Password-Locker-8.3"><span class="toc-item-num">8.3&nbsp;&nbsp;</span>Project: Password Locker</a></span><ul class="toc-item"><li><span><a href="#Step-1:-Program-Design-and-Data-Structures" data-toc-modified-id="Step-1:-Program-Design-and-Data-Structures-8.3.1"><span class="toc-item-num">8.3.1&nbsp;&nbsp;</span>Step 1: Program Design and Data Structures</a></span></li></ul></li><li><span><a href="#Project:-Adding-Bullets-to-Wiki-Markup" data-toc-modified-id="Project:-Adding-Bullets-to-Wiki-Markup-8.4"><span class="toc-item-num">8.4&nbsp;&nbsp;</span>Project: Adding Bullets to Wiki Markup</a></span></li><li><span><a href="#Summary" data-toc-modified-id="Summary-8.5"><span class="toc-item-num">8.5&nbsp;&nbsp;</span>Summary</a></span></li><li><span><a href="#Practice-Project" data-toc-modified-id="Practice-Project-8.6"><span class="toc-item-num">8.6&nbsp;&nbsp;</span>Practice Project</a></span><ul class="toc-item"><li><span><a href="#Table-Printer" data-toc-modified-id="Table-Printer-8.6.1"><span class="toc-item-num">8.6.1&nbsp;&nbsp;</span>Table Printer</a></span></li></ul></li></ul></li><li><span><a href="#Classes-and-Objects" data-toc-modified-id="Classes-and-Objects-9"><span class="toc-item-num">9&nbsp;&nbsp;</span>Classes and Objects</a></span><ul class="toc-item"><li><span><a href="#Some-points-on-Python-class:" data-toc-modified-id="Some-points-on-Python-class:-9.1"><span class="toc-item-num">9.1&nbsp;&nbsp;</span>Some points on Python class:</a></span></li><li><span><a href="#Defining-a-class" data-toc-modified-id="Defining-a-class-9.2"><span class="toc-item-num">9.2&nbsp;&nbsp;</span>Defining a class</a></span></li><li><span><a href="#Class-Objects" data-toc-modified-id="Class-Objects-9.3"><span class="toc-item-num">9.3&nbsp;&nbsp;</span>Class Objects</a></span><ul class="toc-item"><li><span><a href="#Declaring-an-object" data-toc-modified-id="Declaring-an-object-9.3.1"><span class="toc-item-num">9.3.1&nbsp;&nbsp;</span>Declaring an object</a></span></li></ul></li><li><span><a href="#The-self" data-toc-modified-id="The-self-9.4"><span class="toc-item-num">9.4&nbsp;&nbsp;</span>The self</a></span></li><li><span><a href="#init-method" data-toc-modified-id="init-method-9.5"><span class="toc-item-num">9.5&nbsp;&nbsp;</span><strong>init</strong> method</a></span></li><li><span><a href="#Class-and-Instance-Variables" data-toc-modified-id="Class-and-Instance-Variables-9.6"><span class="toc-item-num">9.6&nbsp;&nbsp;</span>Class and Instance Variables</a></span></li></ul></li></ul></div>

 

 

 

 

 

 

      

      

       

      

     
     
     
     
     
         

    
    
    
    
       
       
       
    







    

      

 

# Python Introduction

## [[Math Operators]] from Highest to Lowest Precedence
    **     Exponent                                 2 ** 3     8
    %      modulus/remainder                        22 % 8     6
    //     Integer division/floored quotient        22 // 8    2
    /      Division                                 22 / 8     2.75
    *      Multiplication                           3 * 5      15
    -      Subtraction                              5 - 2      3
    +      Addition                                 2 + 2      4


```python
2**3
```




    8




```python
22%8
```




    6




```python
22//8
```




    2




```python
22/8
```




    2.75



 ## Data type
  **Every value in Python has a datatype**. **Since everything is an object in Python programming**, data types are actually classes and variables are instance (object) of these classes.
  

    Integers                 -2, -1, 0, 1, 2, 3, 4, 5
    Floating-point numbers   -1.25, -1.0, ‑-0.5, 0.0, 0.5, 1.0, 1.25
    Strings                  'a', 'aa', 'aaa', 'Hello!', '11 cats
    complex                   1+2j
    boolean                   True, False
    list                      [1,2,'binod']
    tuple                     (1, 1.5, "ML")
    set                       {10, 30, 20, 40, 5}
    Dictionary                {'a': "apple", 'b': "bat"}</div><i class="fa fa-lightbulb-o "></i>


```python
a = 5                               #data type is implicitly set to integer
print(a, " is of type", type(a))
```

    5  is of type <class 'int'>
    


```python
a = 2.5                            #data type is changed to float
print(a, " is of type", type(a))
```

    2.5  is of type <class 'float'>
    


```python
a = 1 + 2j                          #data type is changed to complex number
print(a, " is complex number?") 
print(isinstance(1+2j, complex))
```

    (1+2j)  is complex number?
    True
    


```python
a = True                          #a is a boolean type
print(type(a))
```

    <class 'bool'>
    

**Boolean represents the truth values False and True**


```python
a=5
isinstance(a,int)
```




    True




```python
s = "This is Online AI course"
print(type(s))
```

    <class 'str'>
    

**String is sequence of Unicode characters. We can use single quotes or double quotes to represent strings. Multi-line strings can be denoted using triple quotes, ''' or """.**

A string in Python consists of a series or sequence of characters - letters, numbers, and special characters.  Strings can be indexed - often synonymously called subscripted as well. Similar to C, the first character of a string has the index 0.


```python
a = [10, 20.5, "Hello"]
print(type(a))
```

    <class 'list'>
    

**List is an ordered sequence of items. It is one of the most used datatype in Python and is very flexible. All the items in a list do not need to be of the same type.
Declaring a list is , Items separated by commas are enclosed within brackets [ ].**


```python
t = (1, 1.5, "ML")
type(t)
```




    tuple



**Tuple is an ordered sequence of items same as list.The only difference is that tuples are immutable. Tuples once created cannot be modified.**


```python
s = {10, 30, 20, 40, 5}
type(s)
```




    set




```python
s= {10, 30, 20, 40, 5,5,30,40}   #automatically set won't consider duplicate elements
print (s,type(s))
```

    {5, 40, 10, 20, 30} <class 'set'>
    


```python
s = {10, 30, 20, 40, 5}
print(s[1])
#we can't print particular element in set because 
            #it's unorder collections of items
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-15-4f496a5e5d40> in <module>
          1 s = {10, 30, 20, 40, 5}
    ----> 2 print(s[1])
          3 #we can't print particular element in set because
          4             #it's unorder collections of items
    

    TypeError: 'set' object is not subscriptable


**Set is an unordered collection of unique items. Set is defined by values separated by comma inside braces { }. Items in a set are not ordered.**

We can perform set operations like union, intersection on two sets. Set have unique values.


```python
d={'a': "apple", 'b': "bat"}
print(type(d))
```

    <class 'dict'>
    

**Dictionary is an unordered collection of key-value pairs. In Python, dictionaries are defined within braces {} with each item being a pair in the form key:value. Key and value can be of any type.**

**We can convert one sequence to other**


```python
a = [1, 2, 3]

print(type(a))      #type of a is list 

s = set(a)          #convert list to set using set() method

print(type(s))       #now type of s is set
print(s)
```

    <class 'list'>
    <class 'set'>
    {1, 2, 3}
    


```python
list("Hello")       #convert String to list using list() method
```




    ['H', 'e', 'l', 'l', 'o']




```python
'life'+'sucks'
```




    'lifesucks'




```python
'bond'+'007'
```




    'bond007'




```python
'boond'+007
```


      File "<ipython-input-21-85e1f809a746>", line 1
        'boond'+007
                  ^
    SyntaxError: invalid token
    



```python
'Life'*5
```




    'LifeLifeLifeLifeLife'



**The * operator can be used with only two numeric values (for multiplication)
or one string value and one integer value (for string replication).
Otherwise, Python will just display an error message. eg-**


```python
'life'*'sucks'
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-23-f778a72e26f9> in <module>
    ----> 1 'life'*'sucks'
    

    TypeError: can't multiply sequence by non-int of type 'str'



```python
'life'*5.0
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-24-4319b9def653> in <module>
    ----> 1 'life'*5.0
    

    TypeError: can't multiply sequence by non-int of type 'float'



```python
user = "satish"
lines = 100

print("Congratulations, " + user + "! You just wrote " + str(lines) + " lines of code" )
#remove str and gives error
```

    Congratulations, satish! You just wrote 100 lines of code
    

## Storing Values in Variables



```python
spam=42
spam
```




    42




```python
mail=5
mail
```




    5




```python
spam+mail
```




    47




```python
spam+mail+mail
```




    52



#### Multiple Assignments


```python
#We use the assignment operator (=) to assign values to a variable

a = 10
b = 5.5
c = "ML"
```


```python
a, b, c = 10, 5.5, "ML" # Multiple Assignments
print(a,b,c)
```

    10 5.5 ML
    


```python
x = 3

print(id(x))               #print address of variable x
```

    140703233909200
    


```python
y = 3

print(id(y))               #print address of variable y
```

    140703233909200
    

**Observation:**
x and y points to same memory location


```python
y = 2
print(id(y))               #print address of variable y
```

    140703233909168
    

### [[VARIABLE NAMES]]
You can name a variable anything as long as it obeys the following three rules:
    1. It can be only one word.
    2. It can use only letters, numbers, and the underscore (_) character.
    3. It can’t begin with a number.
    
#### Valid variable names________________Invalid variable names

     balance                               current-balance (hyphens are not allowed)
     currentBalance                        current balance (spaces are not allowed)
     current_balance                       4account (can’t begin with a number)
     _spam                                 42 (can’t begin with a number)
     SPAM                                  total_$um (special characters like $ are not allowed)
     account4                             'hello' (special characters like ' are not allowed)

**Variable names are case-sensitive, meaning that spam, SPAM, Spam, and sPaM are four different variables. It is a Python convention to start your variables with a lowercase letter.**

## First Program


```python
print('hello world')
print('what is your name:')
myName= input()
print('its good to meet you '+ myName)
print('length pf your name:')
print(len(myName))
print('whats your age')
age= input()
print('your age will be ' + str(int(age)+1) +  ' in one year')

```

    hello world
    what is your name:
    pky
    its good to meet you pky
    length pf your name:
    3
    whats your age
    25
    your age will be 26 in one year
    

## [[Comments]]
Python ignores comments, and you can use them to write notes or remind yourself what the code is trying to do. Any text for the rest of the line following a hash mark (#) is part of a comment. Sometimes, programmers will put a # in front of a line of code to temporarily remove it while testing a program. This is called commenting out code, and it can be useful when you’re trying to figure out why a program doesn’t work. You can remove the # later when you are ready to put the line back in.
Python also ignores the blank line after the comment. You can add as many blank lines to your program as you want. This can make your code easier to read, like paragraphs in a book.
#This program says hello and asks for my name.

## The print() Function
The print() function displays the string value inside the parentheses on the screen.
You can also use this function to put a blank line on the screen; just call print() with
nothing in between the parentheses.


```python
print("Hello World")
```

    Hello World
    


```python
a = 10
print("The value of a is", a) #python 3
print ("The value of a is " + str(a))
```

    The value of a is 10
    The value of a is 10
    

## The input() Function
The input() function waits for the user to type some text on the keyboard and press enter.
myName = input()


```python
num = input("Enter a number: ")
print (num)
```

    Enter a number: 25
    25
    

### Taking multiple inputs

**Using split() method :**

    input().split(separator, maxsplit)


```python
# Python program showing how to
# multiple input using split

# taking two inputs at a time
x, y = input("Enter a two value: ").split()
print("Number of boys: ", x)
print("Number of girls: ", y)
print()

# taking three inputs at a time
x, y, z = input("Enter a three value: ").split()
print("Total number of students: ", x)
print("Number of boys is : ", y)
print("Number of girls is : ", z)
print()

# taking two inputs at a time
a, b = input("Enter a two value: ").split()
print("First number is {} and second number is {}".format(a, b))
print()

# taking multiple inputs at a time
# and type casting using list() function
x = list(map(int, input("Enter a multiple value: ").split()))
print("List of students: ", x)
```

    Enter a two value: 5 6
    Number of boys:  5
    Number of girls:  6
    
    Enter a three value: 5 9 8
    Total number of students:  5
    Number of boys is :  9
    Number of girls is :  8
    
    Enter a two value: 45 96
    First number is 45 and second number is 96
    
    Enter a multiple value: 45 52 56
    List of students:  [45, 52, 56]
    

**Using List comprehension :** 


```python
# Python program showing
# how to take multiple input
# using List comprehension

# taking two input at a time
x, y = [int(x) for x in input("Enter two value: ").split()]
print("First Number is: ", x)
print("Second Number is: ", y)
print()

# taking three input at a time
x, y, z = [int(x) for x in input("Enter three value: ").split()]
print("First Number is: ", x)
print("Second Number is: ", y)
print("Third Number is: ", z)
print()

# taking two inputs at a time
x, y = [int(x) for x in input("Enter two value: ").split()]
print("First number is {} and second number is {}".format(x, y))
print()

# taking multiple inputs at a time
x = [int(x) for x in input("Enter multiple value: ").split()]
print("Number of list is: ", x)
```

    Enter two value: 5 8
    First Number is:  5
    Second Number is:  8
    
    Enter three value: 8 7 5
    First Number is:  8
    Second Number is:  7
    Third Number is:  5
    
    Enter two value: 56 223
    First number is 56 and second number is 223
    
    Enter multiple value: 556 25 89
    Number of list is:  [556, 25, 89]
    

**Note : The above examples take input separated by spaces. In case we wish to take input separated by comma (, ), we can use following:**


```python
# taking multiple inputs at a time separated by comma
x = [int(x) for x in input("Enter multiple value: ").split(",")]
print("Number of list is: ", x) 
```

    Enter multiple value: 5,6,9,223
    Number of list is:  [5, 6, 9, 223]
    

## The len() Function
You can pass the len() function a string value (or a variable containing a string), and the function evaluates to the integer value of the number of characters in that string.


```python
len('hello')
```




    5




```python
len('life sucks')
```




    10




```python
len('')
```




    0




```python
len(' ')
```




    1



## The str(), int(), and float() Functions
If you want to concatenate an integer such as 29 with a string to pass to print(), you’ll need to get the value '29', which is the string form of 29. The str() function can be passed an integer value and will evaluate to a string value version of it, as follows:


```python
str(29)
```




    '29'




```python
print('i have ' +str(29)+ ' cows')
```

    i have 29 cows
    


```python
a = 10
print("The value of a is", a) #python 3
print ("The value of a is " + str(a))
```

    The value of a is 10
    The value of a is 10
    


```python
str(10.62)
```




    '10.62'




```python
int(10.62)
```




    10




```python
float(10)
```




    10.0




```python
int('10')
```




    10




```python
int('10.5')
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-50-6cc59efdcec3> in <module>
    ----> 1 int('10.5')
    

    ValueError: invalid literal for int() with base 10: '10.5'


#### Text and Number Equivalence
Although the string value of a number is considered a completely different
value from the integer or floating-point version, an integer can be equal to a
floating point.

    42 == '42'
    False
    True
    42.0 == 0042.000
    True

Python makes this distinction because strings are text, while integers and
floats are both numbers.


```python
round(8.96538,3)
```




    8.965




```python
round(8.9321,2)
```




    8.93



 ## Output Formatting



```python
a = 10; b = 20 #multiple statements in single line.

print("The value of a is {} and b is {}".format(a, b))    #default
```

    The value of a is 10 and b is 20
    


```python
a = 10; b = 20  #multiple statements in single line

print("The value of b is {1} and a is {0}".format(a, b)) #specify position of arguments
```

    The value of b is 20 and a is 10
    


```python
#we can use keyword arguments to format the string

print("Hello {name}, {greeting}".format(name="satish", greeting="Good Morning"))
```

    Hello satish, Good Morning
    


```python
#we can combine positional arguments with keyword arguments

print('The story of {0}, {1}, and {other}'.format('Bill', 'Manfred',other='Georg'))
```

    The story of Bill, Manfred, and Georg
    


```python
#code for disabling the softspace feature 
print('G','F','G', sep='') 

#for formatting a date 
print('09','12','2016', sep='-') 

#another example 
print('pratik','geeksforgeeks', sep='@') 

```

    GFG
    09-12-2016
    pratik@geeksforgeeks
    


```python
# This Python program must be run with 
# Python 3 as it won't work with 2.7. 

# ends the output with a <space> 
print("Welcome to" , end = ' ') 
print("GeeksforGeeks", end = ' ') 

```

    Welcome to GeeksforGeeks 


```python
print('G','F', sep='', end='') 
print('G') 
#\n provides new line after printing the year 
print('09','12', sep='-', end='\n') 

print('prtk','agarwal', sep='', end='@') 
print('geeksforgeeks') 

```

    GFG
    09-12
    prtkagarwal@geeksforgeeks
    


```python
# Python program showing how to use
# string modulo operator(%) to print
# fancier output

# print integer and float value
print("Geeks : % 2d, Portal : % 5.2f" %(1, 05.333)) 

# print integer value
print("Total students : % 3d, Boys : % 2d" %(240, 120))

# print octal value
print("% 7.3o"% (25))

# print exponential value
print("% 10.3E"% (356.08977))

```

    Geeks :  1, Portal :  5.33
    Total students :  240, Boys :  120
        031
     3.561E+02
    

**Let’s take a look at the placeholders in our example.**

     %[flags][width][.precision]type 
The first placeholder “%2d” is used for the first component of our tuple, i.e. the integer 1. The number will be printed with 2 characters. As 1 consists only of one digit, the output is padded with 1 leading blanks.

The second one “%5.2f” is a format description for a float number. Like other placeholders, it is introduced with the % character. This is followed by the total number of digits the string should contain. This number includes the decimal point and all the digits, i.e. before and after the decimal point.

Our float number 05.333 has to be formatted with 5 characters. The decimal part of the number or the precision is set to 2, i.e. the number following the “.” in our placeholder. Finally, the last character “f” of our placeholder stands for “float”.


```python
# Python program showing
# a use of format() method

# combining positional and keyword arguments
print('Number one portal is {0}, {1}, and {other}.'.format('Geeks','For',other='Geeks'))

# using format() method with number
print("Geeks :{0:2d}, Portal :{1:8.2f}".format(12, 00.546))

# Changing positional argument
print("Second argument: {1:3d}, first one: {0:7.2f}".format(47.42, 11))

print("Geeks: {a:5d}, Portal: {p:8.2f}".format(a=453, p=59.058))
```

    Number one portal is Geeks, For, and Geeks.
    Geeks :12, Portal :    0.55
    Second argument:  11, first one:   47.42
    Geeks:   453, Portal:    59.06
    

# Flow Control

#### Comparison Operators

Operator      Meaning
    ==      Equal to
    !=      Not equal to
    <       Less than
    >       Greater than
    <=      Less than or equal to
    >=      Greater than or equal to


```python
42==56
```




    False




```python
42==7*6
```




    True




```python
45!=56
```




    True




```python
45>=23
```




    True




```python
42=='42'
```




    False




```python
'hello'=='Hello'
```




    False



### The Difference Between the == and = Op erators

You might have noticed that the == operator (equal to) has two equal signs, while the = operator (assignment) has just one equal sign. It’s easy to confuse these two operators with each other. Just remember these points:

    • The == operator (equal to) asks whether two values are the same as each other.
    • The = operator (assignment) puts the value on the right into the variable on the left.

To help remember which is which, notice that the == operator (equal to) consists of two characters, just like the != operator (not equal to) consists of two characters.



## Boolean (Logical) Operators

The three Boolean operators **(and, or, and not)** are used to compare Boolean
values. Like comparison operators, they evaluate these expressions down
to a Boolean value.


```python
True and True
```




    True




```python
True and False
```




    False




```python
False and False
```




    False




```python
True or True
```




    True




```python
True or False
```




    True




```python
False or False
```




    False




```python
not True
```




    False




```python
not not True
```




    True




```python
(5>4) and (5>6)
```




    False




```python
(5>4) or (5>6)
```




    True




```python
2+2==4 and not 2+2==5 and 4==2*2
```




    True



## Bitwise operators
Bitwise operators act on operands as if they were string of binary digits. It operates bit by bit

    &,  |,  ~,  ^,  >>,  << are Bitwise operators


```python
a, b = 10, 4

#Bitwise AND
print(a & b) #10=1010, 4=0100 so 10&4(=1*0 0*1 1*0 0*0)=0

#Bitwise OR
print(a | b) #1or0 0or1 1or0 0or0=1110 in binary=14 in decimal

#Bitwise NOT


#Bitwise XOR


#Bitwise rightshift


#Bitwise Leftshift
```

    0
    14
    

##  Identity Operators
**is** and **is not** are the identity operators in Python. They are **used to check if two values (or variables) are located on the same part of the memory.**


```python
a = 5
b = 5
print(a is b)    #5 is object created once both a and b points to same object

print(id(a))                 #two values (or variables) are located on the same part of the memory.
print(id(b))  
```

    True
    140703233909264
    140703233909264
    


```python
l1 = [1, 2, 3]
l2 = [1, 2, 3]
print(l1 is l2)        #two values (or variables) are located on the different part of the memory.

print(id(l1))
print(id(l2)) 
```

    False
    1571736909192
    1571735146888
    


```python
s1 = "Satish"
s2 = "Satish"           #two values (or variables) are located on the same part of the memory.
print(s1 is not s2)

print(id(s1))                
print(id(s2)) 
```

    False
    1571735124656
    1571735124656
    

## MemberShip Operators
**in** and **not in** are the **membership operators in Python.**
They are used to **test whether a value or variable is found in a sequence (string, list, tuple, set and dictionary).**


```python
d = {1: "a", 2: "b"}
print(1 in d)
```

    True
    


```python
d = {1: "a", 2: "b"}
print(1 in d)
```

    True
    

## Elements of Flow Control

Flow control statements often start with a part called the condition, and all are followed by a block of code called the clause. Before you learn about Python’s specific flow control statements, I’ll cover what a condition and a block are.

### Conditions
condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, True or False. A flow control statement decides what to do based on whether its condition is True or False, and almost every flow control statement uses a condition.

### Blocks of Code
Lines of Python code can be grouped together in blocks. You can tell when a block begins and ends from the indentation of the lines of code. There are three rules for blocks.
    1. Blocks begin when the indentation increases.
    2. Blocks can contain other blocks.
    3. Blocks end when the indentation decreases to zero or to a containing block’s indentation.



## Flow Control Statements

### if Statements

In plain English, an if statement could be read as, “If this condition is
true, execute the code in the clause.” In Python, an if statement consists of
the following:
    • The if keyword
    • A condition (that is, an expression that evaluates to True or False)
    • A colon
    • Starting on the next line, an indented block(or four spaces) of code (called the if clause)

    if name == 'Alice':
       print('Hi, Alice.')

![title](https://cdn.programiz.com/sites/tutorial2program/files/Python_if_statement.jpg)

### else Statements

An if clause can optionally be followed by an else statement. The else clause is executed only when the if statement’s condition is False. In plain English, an else statement could be read as, “If this condition is true, execute this code. Or else, execute that code.” An else statement doesn’t have a condition, and in code, an else statement always consists of the following:
• The else keyword
• A colon
• Starting on the next line, an indented block of code (called the else clause)

    if name == 'Alice':
        print('Hi, Alice.')
    else:
        print('Hello, stranger.')
![title](https://cdn.programiz.com/sites/tutorial2program/files/Python_if_else_statement.jpg)    
### elif Statements

While only one of the if or else **(else if)** clauses will execute, you may have a case where you want one of many possible clauses to execute. The elif statement is an “else if” statement that always follows an if or another elif statement. It provides another condition that is checked only if any of the previous conditions were False. In code, an elif statement always consists of the following:
    • The elif keyword
    • A condition (that is, an expression that evaluates to True or False)
    • A colon
    • Starting on the next line, an indented block of code (called the elif clause)

Let’s add an elif to the name checker to see this statement in action.

    if name == 'Alice':
        print('Hi, Alice.')
    elif age < 12:
        print('You are not Alice, kiddo.')
![title](https://cdn.programiz.com/sites/tutorial2program/files/Python_if_elif_else_statement.jpg)
This time, you check the person’s age, and the program will tell them something different if they’re younger than 12. he elif clause executes if age < 12 is True and name == 'Alice' is False. However, if both of the conditions are False, then both of the clauses are skipped. It is not guaranteed that at least one of the clauses will be executed. When there is a chain of elif statements, only one or none of the clauses will be executed. Once one of the statements’ conditions is found to be True, the rest of the elif clauses are automatically skipped.
    
    if name == 'Alice':
        print('Hi, Alice.')
    elif age < 12:
        print('You are not Alice, kiddo.')
    elif age > 2000:
        print('Unlike you, Alice is not an undead, immortal vampire.')
    elif age > 100:
        print('You are not Alice, grannie.')
        
Here I’ve added two more elif statements to make the name checker greet a person with different answers based on age.

Optionally, you can have an else statement after the last elif statement. In that case, it is guaranteed that at least one (and only one) of the clauses will be executed. If the conditions in every if and elif statement are False, then the else clause is executed. For example, let’s re-create the Alice program to use if, elif, and else clauses.

    if name == 'Alice':
        print('Hi, Alice.')
    elif age < 12:
        print('You are not Alice, kiddo.')
    else:
        print('You are neither Alice nor a little kid.')

In plain English, this type of flow control structure would be, “If the first condition is true, do this. Else, if the second condition is true, do that. Otherwise, do something else.”
### Nested if Statements
We can have a if...elif...else statement inside another if...elif...else statement. This is called nesting in computer programming.

    num = 10.5

    if num >= 0:
        if num == 0:
            print("Zero")
        else:
            print("Positive number")
    else:
        print("Negative Number")
        

### while Loop Statements

You can make a block of code execute over and over again with a while statement. **The code in a while clause will be executed as long as the while statement’s condition is True.** In code, a while statement always consists of the following:
    • The while keyword
    • A condition (that is, an expression that evaluates to True or False)
    • A colon
    • Starting on the next line, an indented block of code (called the while clause)
    
        spam = 0
        if spam < 5:
            print('Hello, world.')
            spam = spam + 1
Here is the code with a while statement:

        spam = 0
        while spam < 5:
            print('Hello, world.')
            spam = spam + 1
![title](https://cdn.programiz.com/sites/tutorial2program/files/whileLoopFlowchart.jpg)        
These statements are similar—both if and while check the value of spam, and if it’s less than five, they print a message. But when you run these two code snippets, something very different happens for each one. For the if statement, the output is simply "Hello, world.". But for the while statement, it’s "Hello, world." repeated five times!
The code with the if statement checks the condition, and it prints Hello, world. only once if that condition is true. The code with the while loop, on the other hand, will print it five times. It stops after five prints because the integer in spam is incremented by one at the end of each loop iteration, which means that the loop will execute five times before spam < 5 is False.


```python
num = 10

if num > 10:                        # try 0, -1 and None
    print("Number is positive")
print("This will print always")      #This print statement always print

                                    #change number 
```

    This will print always
    


```python
num = 10

                                      # try 0, -1 and None
if 0:
    print("Number is positive")
    
print("This will print always")      #This print statement always print

```

    This will print always
    


```python
num = 10

                                      # try 0, -1 and None
if -1:
    print("Number is positive")
    
print("This will print always")      #This print statement always print
```

    Number is positive
    This will print always
    


```python
num = 10

                                      # try 0, -1 and None
if None:
    print("Number is positive")
    
print("This will print always")      #This print statement always print
```

    This will print always
    


```python
num = 10

                                      # try 0, -1 and None
if False:
    print("Number is positive")
    
print("This will print always")      #This print statement always print
```

    This will print always
    


```python
num = 10

                                      # try 0, -1 and None
if True:
    print("Number is positive")
    
print("This will print always")      #This print statement always print
```

    Number is positive
    This will print always
    

**0, None, False considered as false, everything else considered as true**


```python
num = 0

if num > 0:
    print("Positive number")
elif num == 0:
    print("ZERO")
else:
    print("Negative Number")
```

    ZERO
    


```python
num = 10.5

if num >= 0:
    if num == 0:
        print("Zero")
    else:
        print("Positive number")
else:
    print("Negative Number")
```

    Positive number
    

**Python program to find the largest element among three Numbers**


```python
num1 = 10
num2 = 50
num3 = 15

if (num1 >= num2) and (num1 >= num3):           #logical operator   and
    largest = num1
elif (num2 >= num1) and (num2 >= num3):
    largest = num2
else:
    largest = num3
print("Largest element among three numbers is: {}".format(largest))
```

    Largest element among three numbers is: 50
    


```python
#An Annoying while Loop
name=''   #First, the program sets the name variable to an empty string.
while name!= 'your name':
    print('type your name')
    name= input()
print('thank you')
```

    type your name
    pky
    type your name
    your name
    thank you
    


```python
#Find product of all numbers present in a list

lst = [10, 20, 30, 40, 60]

product = 1
index = 0

while index < len(lst):
    product *= lst[index]
    index += 1

print("Product is: {}".format(product))
```

    Product is: 14400000
    


```python
while name!= 'your name': #variable not set to any string so
    print('type your name')
    name= input()
print('thank you')
```

    thank you
    

### while Loop with else
Same as that of for loop, we can have an optional else block with while loop as well.

The else part is executed if the condition in the while loop evaluates to False. The while loop can be terminated with a break statement.

In such case, the else part is ignored. Hence, a while loop's else part runs if no break occurs and the condition is false.


```python
numbers = [1, 2, 3]

#iterating over the list
index = 0
while index < len(numbers):
    print(numbers[index])
    index += 1              #IF YOU FORGET IT TO WRITE, THIS LOOP WILL KEEP RUNNING (INFNITE LOOP)
    
else:
    print("no item left in the list")
```

    1
    2
    3
    no item left in the list
    

#### Python Program to check given number is Prime number or not


```python
num = int(input("Enter a number: "))        #convert string to int


isDivisible = False;

i=2;
while i < num:
    if num % i == 0:
        isDivisible = True;
        print ("{} is divisible by {}".format(num,i) )
    i += 1;
    
if isDivisible:
    print("{} is NOT a Prime number".format(num))
else:
    print("{} is a Prime number".format(num))

```

    Enter a number: 25
    25 is divisible by 5
    25 is NOT a Prime number
    

###  break Statements
In Python, break and continue statements can alter the flow of a normal loop. Loops iterate over a block of code until test expression is false, but sometimes we wish to terminate the current iteration or even the whole loop without cheking test expression.

![title](https://cdn.programiz.com/sites/tutorial2program/files/flowchart-break-statement.jpg)
There is a shortcut to getting the program execution to break out of a while loop’s clause early. If the execution reaches a break statement, it immediately exits the while loop’s clause. In code, a break statement simply contains the break keyword.
Pretty simple, right? Here’s a program that does the same thing as the previous program, but it uses a break statement to escape the loop.
![title](https://cdn.programiz.com/sites/tutorial2program/files/how-break-statement-works.jpg)


```python
numbers = [1, 2, 3, 4]

for num in numbers:          #iterating over list
    if num == 4:
        break
    print(num)
    
else:                             #else is also part of for loop
    print("in the else-block")
    
print("Outside of for loop")
```

    1
    2
    3
    Outside of for loop
    

**Python Program to check given number is Prime number or not (using break)**


```python
num = int(input("Enter a number: "))                   #convert string to int

isDivisible = False;
i=2;

while i < num:
    if num % i == 0:
        isDivisible = True;
        print ("{} is divisible by {}".format(num,i) )
        break;                                         # this line is the only addition. (in above program)
    i += 1;
    
    
if isDivisible:
    print("{} is NOT a Prime number".format(num))
else:
    print("{} is a Prime number".format(num))
```

    Enter a number: 25
    25 is divisible by 5
    25 is NOT a Prime number
    


```python
while True:
    print('input your name')
    name=input()
    if name=='your name':
        break
print('thank you')
```

    input your name
    pky
    input your name
    your name
    thank you
    

### continue Statements
![title](https://cdn.programiz.com/sites/tutorial2program/files/continue-statement-flowchart.jpg)
Like break statements, continue statements are used inside loops. When the execution reaches a continue statement, the program execution immediately jumps back to the start of the loop and reevaluates the loop’s condition. (This is also what happens when the execution reaches the end of the loop.)
![title](https://cdn.programiz.com/sites/tutorial2program/files/how-continue-statment-works.jpg)


```python
#print odd numbers present in a list
numbers = [1, 2, 3, 4, 5]

for num in numbers:
    if num % 2 == 0:
        continue
    print(num)
else:
    print("else-block")
```

    1
    3
    5
    else-block
    


```python
while True:
    print('who are you')
    name= input()
    if name!='ket':
        continue
    print('heloo ket, what is password')
    pswrd=input()
    if pswrd=='gate1':
        break
print('welcome')
```

    who are you
    pky
    who are you
    ket
    heloo ket, what is password
    gate1
    welcome
    

#### “Truthy” and “Fa lsey” Values
There are some values in other data types that conditions will consider equivalent to True and False. When used in conditions, 0, 0.0, and '' (the empty string) are considered False, while all other values are considered True. For example, look at the following program:

    name = ''
    while not name:
        print('Enter your name:')
        name = input()
    print('How many guests will you have?')
    numOfGuests = int(input())
    if numOfGuests:
        print('Be sure to have enough room for all your guests.')
    print('Done')
    
If the user enters a blank string for name, then the while statement’s condition will be True u, and the program continues to ask for a name. If the value for numOfGuests is not 0 v, then the condition is considered to be True, and the program will print a reminder for the user w. You could have typed not name != '' instead of not name, and numOfGuests != 0 instead of numOfGuests, but using the truthy and falsey values can make your code easier to read.

### for Loops and the range() Function
The while loop keeps looping while its condition is True (which is the reason for its name), but what if you want to execute a block of code only a certain number of times? You can do this with a for loop statement and the range() function
In code, a for statement looks something like for i in range(5): and
always includes the following:
    • The for keyword
    • A variable name
    • The in keyword
    • A call to the range() method with up to three integers passed to it
    • A colon
    • Starting on the next line, an indented block of code (called the for clause)
![title](https://cdn.programiz.com/sites/tutorial2program/files/forLoop.jpg)    
Let’s create a new program called fiveTimes.py to help you see a for loop
in action.


```python
#Find product of all numbers present in a list

lst = [10, 20, 30, 40, 50]

product = 1
#iterating over the list
for ele in lst:
    print(type(ele))
    product *= ele

print("Product is: {}".format(product))
```

    <class 'int'>
    <class 'int'>
    <class 'int'>
    <class 'int'>
    <class 'int'>
    Product is: 12000000
    


```python
print('may name is:')
for i in range(5):
    print('pky five time('+str(i)+')')
```

    may name is:
    pky five time(0)
    pky five time(1)
    pky five time(2)
    pky five time(3)
    pky five time(4)
    


```python
print('sum first of 100 number')
s=0
for i in range(100):
    i=i+1
    s=s+i
print(s)
```

    sum first of 100 number
    5050
    


```python
print('sum first of n number')
print('enter value of n')
n=int(input())
s=0
for i in range(n+1):
    s=s+i
print(s)
```

    sum first of n number
    enter value of n
    6
    21
    


```python
print('sum first of n number')
print('enter value of n')
n=int(input())
i=0
s=0
for i in range(n):
    i=i+1
    s=s+i
print(s)
```

    sum first of n number
    enter value of n
    6
    21
    


```python
print('sum first of 4 number')
s=0
for i in range(4):
    i=i+2
    s=s+i
print(s)
```

    sum first of 4 number
    14
    

#### for loop with else
A for loop can have an optional else block as well. The else part is executed if the items in the sequence used in for loop exhausts.

break statement can be used to stop a for loop. In such case, the else part is ignored.

Hence, a for loop's else part runs if no break occurs.


```python
numbers = [1, 2, 3]

#iterating over the list
for item in numbers:
    print(item)
else:
    print("no item left in the list")
```

    1
    2
    3
    no item left in the list
    


```python
for item in numbers:
    print(item)
    if item % 2 == 0:
        break
else:
    print("no item left in the list")
```

    1
    2
    

#### The Starting, Stopping, and Stepping Arguments to range()

    for i in range(12, 16):
        print(i)
The first argument will be where the for loop’s variable starts, and the
second argument will be up to, but not including, the number to stop at.


```python
for i in range(12, 16):
    print(i)
```

    12
    13
    14
    15
    

The range() function can also be called with three arguments. The first
two arguments will be the start and stop values, and the third will be the
step argument. The step is the amount that the variable is increased by after
each iteration.
    
    for i in range(0, 10, 2):
        print(i)
        
So calling range(0, 10, 2) will count from zero to eight by intervals of two.


```python
for i in range(0, 10, 2):
        print(i)
```

    0
    2
    4
    6
    8
    

you can even use
a negative number for the step argument to make the for loop count down
instead of up.

    for i in range(5, -1, -1):
        print(i)

Running a for loop to print i with range(5, -1, -1) should print from
five down to zero.


```python
for i in range(5,-1,-1):
    print(i)
```

    5
    4
    3
    2
    1
    0
    

#### Python Program to display all prime numbers within an interval


```python
index1 = 20
index2 = 50

print("Prime numbers between {0} and {1} are :".format(index1, index2))

for num in range(index1, index2+1):      #default step size is 1
    if num > 1:
        isDivisible = False;
        for index in range(2, num):
            if num % index == 0:
                isDivisible = True;
        if not isDivisible:        
            print(num);
```

    Prime numbers between 20 and 50 are :
    23
    29
    31
    37
    41
    43
    47
    

### pass Statement
The pass statement is a null statement. But the difference between pass and comment is that comment is ignored by the interpreter whereas pass is not ignroed. 

The pass statement is generally used as a placeholder i.e. when the user does not know what code to write. So user simply places pass at that line. Sometimes, pass is used when the user doesn’t want any code to execute. So user simply places pass there as empty code is not allowed in loops, function definitions, class definitions, or in if statements. So using pass statement user avoids this error.


```python
li = ['a', 'b', 'c', 'd']

for i in li:
    if (i == 'a'):
        pass
    else:
        print(i)
```

    b
    c
    d
    


```python
a = 10
b = 20

if(a<b): 
    pass
else: 
    print("b<a")
```

## Importing Modules
All Python programs can call a basic set of functions called built-in functions, including the print(), input(), and len() functions you’ve seen before. Python also comes with a set of modules called the standard library. Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the math module has mathematicsrelated functions, the random module has random number–related functions, and so on. Before you can use the functions in a module, you must import the module with an import statement. In code, an import statement consists of
the following:
    • The import keyword
    • The name of the module
    • Optionally, more module names, as long as they are separated by commas
Once you import a module, you can use all the cool functions of that module. Let’s give it a try with the random module, which will give us access to the random.ranint() function.


```python
import random
for i in range(5):
    print(random.randint(1,10))
```

    10
    10
    2
    3
    8
    


```python
#program for sum of n odd no

print('enter the n')
n=int(input())
a=2*n-1
s=0

for i in range(1,a+1,2):
    print(i,end='+')
    s=s+i
    
print('\nsum of ('+str(n)+') odd number is=(' +str(s)+ ')')
```

    enter the n
    3
    1+3+5+
    sum of (3) odd number is=(9)
    

The random.randint() function call evaluates to a random integer value between the two integers that you pass it. Since randint() is in the random module, you must first type random. in front of the function name to tell Python to look for this function inside the random module. Here’s an example of an import statement that imports four different modules:

    import random, sys, os, math

Now we can use any of the functions in these four modules. We’ll learn more about them later in the book




## Ending a Program Early with sys.exit()

The last flow control concept to cover is how to terminate the program. This always happens if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.




```python
import sys
while True:
    print('enter exit to exit')
    response=input()
    if response=='exit':
        sys.exit()
    print('you typed'+response+'.')

```

    enter exit to exit
    exit
    


    An exception has occurred, use %tb to see the full traceback.
    

    SystemExit
    


    C:\Users\ASUS\anaconda3\lib\site-packages\IPython\core\interactiveshell.py:3339: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.
      warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)
    

# Functions
You’re already familiar with the print(), input(), and len() functions from the previous chapters. Python provides several builtin functions like these, but you can also write your own functions. A function is like a mini-program within a program.




```python
def hello():
    print('heloo india')
    print('tu jaane na')
hello()
hello()
```

    heloo india
    tu jaane na
    heloo india
    tu jaane na
    

## def Statements with Parameters
When you call the print() or len() function, you pass in values, called arguments in this context, by typing them between the parentheses. You can also define your own functions that accept arguments.


```python
def hello(name):
    print("sleep is bad " +name)
    print('you will '+ name)
hello('pk')
```

    sleep is bad pk
    you will pk
    

## Return Values and return Statements
In general, the value that a function call evaluates to is called the return value of the function. When creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following:

    • The return keyword
    • The value or expression that the function should 
When an expression is used with a return statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on what number it is passed as an argument   


```python
import random
def getAnswer(ans):
    if ans==1:
        return '1 is not a good choice'
    elif ans==2:
        return '2 relly'
    elif ans==3:
        return 'nice try'
    elif ans==4:
        return 'never loose hope'
    elif ans==5:
        return 'you are just about to reach'
    elif ans==6:
        return '6 is not alwya max'
    elif ans==7:
        return 'try your best'
    elif ans==8:
        return '8 goos but not tru'
    elif ans==9:
        return '9 bingo'
print(getAnswer(random.randint(1,9)))
```

    8 goos but not tru
    

## The None Value
-The None keyword is used to define a null value, or no value at all.
-None is not the same as 0, False, or an empty string. None is a datatype of its own (NoneType) and only None can be None.
-Comparing None to anything will always return False except None itself.



```python
# Declaring a None variable using is operator
var = None

if var is None: # Checking if the variable is None
  print("None")
else:
  print("Not None")
```

    None
    


```python
# Declaring a None variable usin == operator
var = None

if var == None: # Checking if the variable is None
  print("None")
else:
  print("Not None")
```

    None
    


```python
# Declaring a variable and initializing with None type
typeOfNone = type(None) 

print(typeOfNone)
```

    <class 'NoneType'>
    


```python
# Comparing None with none and printing the result
print (None == None)
```

    True
    


```python
# Comparing none with False and printing the result
print(None == False)
```

    False
    


```python
# Declaring an empty string
str = ""
# Comparing None with empty string and printing the result
print (str == None)
```

    False
    

This value-without-a-value can be helpful when you need to store something that won’t be confused for a real value in a variable. One place where None is used is as the return value of print(). The print() function displays text on the screen, but it doesn’t need to return anything in the same way len() or input() does. But since all function calls need to evaluate to a return value, print() returns None. To see this in action, enter the following into the interactive shell:


```python
spam = print('Hello!')
None == spam
```

    Hello!
    




    True



Behind the scenes, Python adds return *None* to the end of any function definition with no return statement. This is similar to how a while or for loop implicitly ends with a continue statement. Also, if you use a return statement without a value (that is, just the return keyword by itself), then None is returned.

## Keyword Arguments and print()
   Most arguments are identified by their position in the function call. For example, random.randint(1, 10) is different from random.randint(10, 1). The function call random.randint(1, 10) will return a random integer between 1 and 10, because the first argument is the low end of the range and the second argument is the high end (while random.randint(10, 1) causes an error).
   However, *keyword arguments* are identified by the keyword put before them in the function call. Keyword arguments are often used for optional parameters. For example, the *print()* function has the optional parameters *end* and *sep* to specify what should be printed at the end of its arguments and between its arguments (separating them), respectively.
   If you ran the following program:


```python
print('hello')
print('pramod')
```

    hello
    pramod
    


```python
print('hello',end='')
print('Pramod')
```

    helloPramod
    

Similarly, when you pass multiple string values to print(), the function will automatically separate them with a single space. Enter the following into the interactive shell:


```python
print('cat','dog','mice')
```

    cat dog mice
    


```python
'''But you could replace the default separating string by passing the sep
keyword argument. Enter the following into the interactive shell:'''

print('cat','dog','mice', sep=',')
```

    cat,dog,mice
    

You can add keyword arguments to the functions you write as well, but first you’ll have to learn about the list and dictionary data types in the next two chapters.

## Local and Global Scope
   Parameters and variables that are assigned in a called function are said to exist in that function’s *local scope*. Variables that are assigned outside all functions are said to exist in the *global scope*. A variable that exists in a local scope is called a *local variable*, while a variable that exists in the global scope is called a *global variable*. A variable must be one or the other; it cannot be both local and global.

### Local Variables Cannot Be Used in the Global Scope
Consider this program, which will cause an error when you run it:


```python
def spam():
    egg=25
spam()
print(egg)
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-128-664ed55639e4> in <module>
          2     egg=25
          3 spam()
    ----> 4 print(egg)
    

    NameError: name 'egg' is not defined


The error happens because the eggs variable exists only in the local scope created when spam() is called. Once the program execution returns from spam, that local scope is destroyed, and there is no longer a variable named eggs. So when your program tries to run print(eggs), Python gives you an error saying that eggs is not defined.

### Local Scopes Cannot Use Variables in Other Local Scopes
A new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:


```python
def spam(): 
    egg=99   #u
    bacon()   #v
    print(egg)  #w
def bacon():
    ham=101
    egg=0   #x
spam()    #y
```

    99
    

   When the program starts, the spam() function is called y, and a localscope is created. The local variable eggs u is set to 99. Then the bacon() function is called v, and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable ham is set to 101, and a local variable eggs—which is different from the one in spam()’s local scope—is also created x and set to 0.
   When bacon() returns, the local scope for that call is destroyed. The program execution continues in the spam() function to print the value of eggs w, and since the local scope for the call to spam() still exists here, the eggs variable is set to 99. This is what the program prints.
   The upshot is that local variables in one function are completely separate from the local variables in another function

### Global Variables Can Be Read from a Local Scope
   Consider the following program:


```python
def spam():
    print(eggs)
eggs=42
spam()
print(eggs)
```

    42
    42
    

Since there is no parameter named eggs or any code that assigns eggs a value in the spam() function, when eggs is used in spam(), Python considers it a reference to the global variable eggs. This is why 42 is printed when the previous program is run.

### Local and Global Variables with the Same Name
   To simplify your life, avoid using local variables that have the same name as a global variable or another local variable. But technically, it’s perfectly legal to do so in Python.


```python
def spam():
    egg='spm local 10'
    print(egg)
def bacon():
    egg='bcon local 20'
    print(egg)
    spam()
    print(egg)
egg='global 60'
bacon()
print(egg)
```

    bcon local 20
    spm local 10
    bcon local 20
    global 60
    

There are actually three different variables in this program, but confusingly they are all named eggs. The variables are as follows:
-A variable named eggs that exists in a local scope when spam() is called.
-A variable named eggs that exists in a local scope when bacon() is called.
-A variable named eggs that exists in the global scope.


## The global Statement
   If you need to modify a global variable from within a function, use the global statement. If you have a line such as *global eggs* at the top of a function, it tells Python, *“In this function, eggs refers to the global variable, so don’t create a local variable with this name.”*


```python
def spam():
    global egg      #1 In this function, eggs refers to the global variable
    egg='spam 10'    #global as #1 mentioned
egg='global 20'     #2 global variable
spam()              #spam function calle so again #1 exicuted and global variable value change
print(egg)
```

    spam 10
    


```python
def spam():
    global egg    #1 In this function, eggs refers to the global variable
    egg='spam 10'
egg='global 20'   #2 global variable
print(egg)        #output will be 'global 20' as spam() not called so value wont change
```

    global 20
    


```python
def spam():
                  #global variable not mentioned so it is a local variable
    egg='spam 10' #local variable
    
egg='global 20'   #global variable
spam()            #spam() is called but varioble value wont change as global not mentioned in spam() funtion
print(egg)
```

    global 20
    

There are four rules to tell whether a variable is in a local scope or global scope:

1. If a variable is being used in the global scope (that is, outside of all functions), then it is always a global variable.
2. If there is a global statement for that variable in a function, it is a global variable.
3. Otherwise, if the variable is used in an assignment statement in the function, it is a local variable.
4. But if the variable is not used in an assignment statement, it is a global variable.



```python
def spam():
    global egg
    egg='spam 10'   #global var
def ham():
    egg='ham'       #local
def bacon():
    print(egg)      #global will print
egg='global 60'     #global
spam()              
print(egg)

```

    spam 10
    

   #### Note:
   In a function, a variable will either always be global or always be local. There’s no way that the code in a function can use a local variable named eggs and then later in that same function use the global eggs variable.
   
   *If you ever want to modify the value stored in a global variable from in a function, you must use a global statement on that variable.*
   
   If you try to use a local variable in a function before you assign a valueto it, as in the following program, Python will give you an error.


```python
def spam():
    print(egg)       #1 Error:print(eggs) is executed before eggs is assigned anything, the local variable eggs doesn’t exist.
    egg='local 10'
egg='global 60'      #2 Python will not fall back to using the global eggs variable 
spam()           
```


    ---------------------------------------------------------------------------

    UnboundLocalError                         Traceback (most recent call last)

    <ipython-input-136-a1346586c8a0> in <module>
          3     egg='local 10'
          4 egg='global 60'      #2 Python will not fall back to using the global eggs variable
    ----> 5 spam()
    

    <ipython-input-136-a1346586c8a0> in spam()
          1 def spam():
    ----> 2     print(egg)       #1 Error:print(eggs) is executed before eggs is assigned anything, the local variable eggs doesn’t exist.
          3     egg='local 10'
          4 egg='global 60'      #2 Python will not fall back to using the global eggs variable
          5 spam()
    

    UnboundLocalError: local variable 'egg' referenced before assignment


=> This error happens because Python sees that there is an assignment statement for egg in the *spam()* function #1 and therefore considers *eggs* to be local. But because *print(eggs)* is executed before *egg* is assigned anything, the local variable eggs doesn’t exist. Python will not fall back to using the global eggs variable #2.

=> if we write again like bellow, there will be no error as local var assigned before print(egg)


```python
def spam():
    egg='local 10'   #local var
    print(egg)
egg='global 60'      #global var
spam()              #it will print local var
```

    local 10
    

##### Functions as “Black Boxes”
   Often, all you need to know about a function are its inputs (the parameters) and output value; you don’t always have to burden yourself with how the function’s code actually works. When you think about functions in this high-level way, it’s common to say that you’re treating the function as a “black box.” This idea is fundamental to modern programming. Later chapters in this book will show you several modules with functions that were written by other people. While you can take a peek at the source code if you’re curious, you don’t need to know how these functions work in order to use them. And because writing functions without global variables is encouraged, you usually don’t have to worry about the function’s code interacting with the rest of your program.

## Exception Handling
   Right now, getting an error, or exception, in your Python program means the entire program will crash. You don’t want this to happen in real-world programs. Instead, you want the program to detect errors, handle them, and then continue to run. 
    For example, consider the following program, which has a “ZeroDivisionError” error.
    


```python
def devideBy(num):
    return 42/num

print(devideBy(2))
print(devideBy(3))
print(devideBy(5))

```

    21.0
    14.0
    8.4
    


```python
def devideBy(num):
    return 42/num

print(devideBy(2))
print(devideBy(3))
print(devideBy(5))
print(devideBy(0))
```

    21.0
    14.0
    8.4
    


    ---------------------------------------------------------------------------

    ZeroDivisionError                         Traceback (most recent call last)

    <ipython-input-139-b2dbd009dcb7> in <module>
          5 print(devideBy(3))
          6 print(devideBy(5))
    ----> 7 print(devideBy(0))
    

    <ipython-input-139-b2dbd009dcb7> in devideBy(num)
          1 def devideBy(num):
    ----> 2     return 42/num
          3 
          4 print(devideBy(2))
          5 print(devideBy(3))
    

    ZeroDivisionError: division by zero


A ZeroDivisionError happens whenever you try to divide a number by zero. From the line number given in the error message, you know that the return statement in devideBy() is causing an error. Errors can be handled with try and except statements. The code that could potentially have an error is put in a try clause. The program execution moves to the start of a following except clause if an error happens. You can put the previous divide-by-zero code in a try clause and have an except clause contain code to handle what happens when this error occurs.


```python
def devideBy(num):
    try:
        return 42/num
    except ZeroDivisionError:
        print('invalid')
print(devideBy(2))
print(devideBy(3))
print(devideBy(5))
print(devideBy(0))
print(devideBy(1))
```

    21.0
    14.0
    8.4
    invalid
    None
    42.0
    

When code in a try clause causes an error, the program executionimmediately moves to the code in the except clause. After running that code, the execution continues as normal.

Note that any errors that occur in function calls in a try block will also be caught. Consider the following program, which instead has the *devideBy()* calls in the try block:



```python
def devideBy(num):
    return 42/num
try:
    print(devideBy(2))
    print(devideBy(3))
    print(devideBy(5))
    print(devideBy(0))
    print(devideBy(1))
    print(devideBy(23))
except ZeroDivisionError:
    print('invalid')

```

    21.0
    14.0
    8.4
    invalid
    

The reason *print(devideBy(1)),print(devideBy(23))* is never executed is because once the execution jumps to the code in the except clause, it does not return to the try clause. Instead, it just continues moving down as normal.


```python
print('input the number n')
n=int(input())
def devideBy(num):
    try:
        return n/num
    except ZeroDivisionError:
        print('undefined')
print('input devider')
num=int(input())
print(devideBy(num))
```

    input the number n
    25
    input devider
    5
    5.0
    

## A Short Program: Guess the Number

 “guess the number” game
 When you run this program, the output will look something like this:
 
        I am thinking of a number between 1 and 20.
        Take a guess.
        10
        Your guess is too low.
        Take a guess.
        15
        Your guess is too low.
        Take a guess.
        17
        Your guess is too high.
        Take a guess.
        16
        Good job! You guessed my number in 4 guesses!



```python
#when correct no is 16

print('I am thinking of a number between 1 and 20.')
n=0
i=0
while True:
    i=i+1
    print('Take a guess.')
    n=int(input())
    if n>16:
        print('Your guess is too high.')
    elif n==16:
        break
    elif n<16:
        print('Your guess is too low.')
print('Good job! You guessed my number in '+(str(i))+' guesses!')
```

    I am thinking of a number between 1 and 20.
    Take a guess.
    16
    Good job! You guessed my number in 1 guesses!
    


```python
#when correct no is random & unlimited no of guesses

import random
print('I am thinking of a number between 1 and 20.')
rn = random.randint(1,20)
n=0
i=0
while True:
    i=i+1
    print('Take a guess.')
    n=int(input())
    if n>rn:
        print('Your guess is too high.')
    elif n==rn:
        break
    elif n<rn:
        print('Your guess is too low.')
print('Good job! You guessed my number in ' +(str(i))+ ' guesses!')
```

    I am thinking of a number between 1 and 20.
    Take a guess.
    10
    Your guess is too high.
    Take a guess.
    5
    Your guess is too low.
    Take a guess.
    7
    Your guess is too low.
    Take a guess.
    8
    Your guess is too low.
    Take a guess.
    9
    Good job! You guessed my number in 5 guesses!
    


```python
#when no is random and limited no of guesses

import random
print('I am thinking of a number between 1 and 20.')
rn = random.randint(1,20)                                    # to generate a number for the user to guess
n=0
i=0
for i in range(1,7):                                         # Ask the player to guess 6 times.
    print('Take a guess.')
    n=int(input())
    if n>rn:
        print('Your guess is too high.'#to see whether the guess is less than orgreater than the secret number. 
    elif n<rn:
        print('Your guess is too low.')
    else:
        break                                    #This condition is the correct guess!
if n==rn:
    print('Good job! You guessed my number in ' +(str(i))+ ' guesses!')
else:
    print('Nope. The number I was thinking of was ' + str(rn))

```

    I am thinking of a number between 1 and 20.
    Take a guess.
    10
    Your guess is too low.
    Take a guess.
    15
    Good job! You guessed my number in 2 guesses!
    

After the for loop, the previous if...else statement checks whether the player has correctly guessed the number and prints an appropriate message to the screen.

 ## lambda function
 the lambda keyword is used to create anonymous functions. It has the following syntax:
 
     lambda arguments : expression
     
1. This function can have any number of arguments but only one expression, which is evaluated and returned.
2. One is free to use lambda functions wherever function objects are required.
3. You need to keep in your knowledge that lambda functions are syntactically restricted to a single expression.
4. It has various uses in particular fields of programming besides other types of expressions in functions.     


```python
# Python program to illustrate cube of a number
# showing difference between def() and lambda().


def cube(y):
    return y * y * y

print(cube(5))
```

    125
    


```python
g = lambda x: x * x * x
print(g(7))
```

    343
    

**The lambda function gets more helpful when used inside a function.**


```python
# Python program to demonstrate
# lmabda functions


def power(n):
    return lambda a: a**n


# base = lambda a : a**2 get
# returned to base
base = power(2)         #now pwer 2 will return, lambda a:a**2 so, base=lambda a:a**2, so base(8)=8**2

print("Now power is set to 2")

# when calling base it gets
# executed with already set with 2
print("8 powerof 2 = ", base(8))

# base = lambda a : a**5 get
# returned to base
base = power(5)
print("Now power is set to 5")

# when calling base it gets executed
# with already set with newly 2
print("8 powerof 5 = ", base(8))
```

    Now power is set to 2
    8 powerof 2 =  64
    Now power is set to 5
    8 powerof 5 =  32768
    

## Summary
   Functions are the primary way to compartmentalize your code into logical groups. Since the variables in functions exist in their own local scopes, the code in one function cannot directly affect the values of variables in other functions. This limits what code could be changing the values of your variables, which can be helpful when it comes to debugging your code.
    
   Functions are a great tool to help you organize your code. You can think of them as black boxes: They have inputs in the form of parameters and outputs in the form of return values, and the code in them doesn’t affect variables in other functions.
    
   In previous chapters, a single error could cause your programs to crash. In this chapter, you learned about try and except statements, which can run code when an error has been detected. This can make your programs more resilient to common error cases.


## Practice Projects

### The Collatz Sequence
Write a function named collatz() that has one parameter named number. If number is even, then collatz() should print *number//2* and return this value. If number is odd, then *collatz()* should print and *return 3 * number + 1*. Then write a program that lets the user type in an integer and that keeps calling collatz() on that number until the function returns the value 1.

*(Amazingly enough, this sequence actually works for any integer—sooner or later, using this sequence, you’ll arrive at 1! Even mathematicians aren’t sure why. Your program is exploring what’s called the Collatz sequence, sometimes called “the simplest impossible math problem.”)* R
emember to convert the return value from input() to an integer with the int() function; otherwise, it will be a string value. *Hint: An integer number is even if number % 2 == 0, and it’s odd if number % 2 == 1.*


```python
number=int(input())
def collatz(number):
    if number%2==0:
        number=number//2
        print(number)
        return number
    else:
        number=number*3+1
        print(number)
        return number
while number!=1:
    number=collatz(number)
```

    3
    10
    5
    16
    8
    4
    2
    1
    

###  Input Validation

Add try and except statements to the previous project to detect whether the user types in a noninteger string. Normally, the int() function will raise a ValueError error if it is passed a noninteger string, as in int('puppy'). In the except clause, print a message to the user saying they must enter an integer.


```python
number=(input('enter a no.:'))
def collatz(number):
    if number%2==0:
        n=number//2
        print(n)
        return n
    else:
        n=number*3+1
        print(n)
        return n
try:    
    while number!=1:
        number=collatz(int(number))
except ValueError:
    print('enter a INTEGER no')
```

    enter a no.:3
    10
    5
    16
    8
    4
    2
    1
    

# LISTS

One more topic you’ll need to understand before you can begin writing programs in earnest is the list data type and its cousin, the tuple. Lists and tuples can contain multiple values, which makes it easier to write programs that handle large amounts of data. And since lists themselves can contain other lists, you can use them to arrange data into hierarchical structures.

1. A list is a value that contains multiple values in an **ordered sequence.**
2. Just as string values are typed with quote characters to mark where the string begins and ends, a list begins with an opening square bracket and ends with a closing square bracket, []
3. Values inside the list are also called items. Items are separated with commas (that is, they are comma-delimited).
4. Lists are **mutable,** which means they can be changed.
5. Each item in the list has an assigned index value.
For example-


```python
[1,2,3]
```




    [1, 2, 3]




```python
['cat','bat','rat','elephant']
```




    ['cat', 'bat', 'rat', 'elephant']




```python
['cat', 3.14, True,None]
```




    ['cat', 3.14, True, None]




```python
spam=['cat','bat','rat']
spam
```




    ['cat', 'bat', 'rat']



The spam variable is still assigned only one value: the list value. But the list value itself contains other values. The value [] is an empty list that contains no values, similar to '', the empty string.

### Getting Individual Values in a List with Indexes

Say you have the list *['cat', 'bat', 'rat', 'elephant']* stored in a variable named spam. The Python code *spam[0]* would evaluate to *'cat'*, and *spam[1]* would evaluate to *'bat'*, and so on.
The integer inside the square brackets that follows the list is called an *index*. The first value in the list is at
*index 0*, the second value is at *index 1*, the third value is at *index 2*, and so on.
For example-


```python
spam=['cat','bat','rat']
spam[0]
```




    'cat'




```python
spam[1]
```




    'bat'




```python
spam[2]
```




    'rat'




```python
print (spam[0])
print(spam[1])
print (spam[2])
```

    cat
    bat
    rat
    


```python
'the '+spam[0]+' eats the '+spam[2]
```




    'the cat eats the rat'




```python
spam=['cat','bat','rat']
spam[1110]
```


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    <ipython-input-10-626ecaac1b45> in <module>
          1 spam=['cat','bat','rat']
    ----> 2 spam[1110]
    

    IndexError: list index out of range


Python will give you an *IndexError* error message if you use an index that exceeds the number of values in your list value


```python
spam=['cat','bat','rat']
spam[1.0]
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-11-cf6627e6f4c9> in <module>
          1 spam=['cat','bat','rat']
    ----> 2 spam[1.0]
    

    TypeError: list indices must be integers or slices, not float



```python
Indexes can be only integer values, not floats. The following example will cause a *TypeError error:*
```


      File "<ipython-input-12-5e4a1ec6069b>", line 1
        Indexes can be only integer values, not floats. The following example will cause a *TypeError error:*
                  ^
    SyntaxError: invalid syntax
    



```python
spam[int(1.0)]
```




    'bat'



Lists can also contain other list values. The values in these lists of lists can be accessed using multiple indexes, like so:



```python
spam=[['cat','dog'],'mice','rat','fat',[1,2,3,55]]
spam[0]
```




    ['cat', 'dog']




```python
spam[0][1]
```




    'dog'




```python
spam[0][0]
```




    'cat'




```python
spam[3]
```




    'fat'




```python
spam[4]
```




    [1, 2, 3, 55]




```python
spam[4][3]
```




    55



The first index dictates which list value to use, and the second indicates the value within the list value. For example, spam[0][1] prints 'dog', the second value in the first list.


### Negative Indexes

-While indexes start at 0 and go up, you can also use negative integers for the index.
-The integer value -1 refers to the last index in a list, the value -2 refers to the second-to-last index in a list, and so on. Enter the following into the interactive shell:


```python
spam=[['cat','dog'],'mice','rat','fat',[1,2,3,55]]
spam[-1]
```




    [1, 2, 3, 55]




```python
spam[-1][-1]
```




    55




```python
spam[-1][-3]
```




    2




```python
spam[-2]
```




    'fat'



### Getting Sublists with Slices
Just as an index can get a single value from a list, a slice can get several values from a list, in the form of a new list. A slice is typed between square brackets, like an index, but it has two integers separated by a colon. Notice the difference between indexes and slices.

•	 spam[2] is a list with an index (one integer).
•	 spam[1:4] is a list with a slice (two integers).

In a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new list value. 




```python
spam = ['cat', 'bat', 'rat', 'elephant']
spam[0:2]
    
```




    ['cat', 'bat']




```python
spam[0:-1]
```




    ['cat', 'bat', 'rat']




```python
spam[0:3]
```




    ['cat', 'bat', 'rat']




```python
spam[0:4]
```




    ['cat', 'bat', 'rat', 'elephant']



As a shortcut, you can leave out one or both of the indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0, or the beginning of the list. Leaving out the second index is the same as using the length of the list, which will slice to the end of the list. E


```python
spam[:3]
```




    ['cat', 'bat', 'rat']




```python
spam[:-1]
```




    ['cat', 'bat', 'rat']




```python
spam[:]
```




    ['cat', 'bat', 'rat', 'elephant']




```python
spam[2:]
```




    ['rat', 'elephant']



**print alternate elements in a list, *list[start:end:stepSize]***


```python
numbers = [10, 20, 30, 40, 50,60,70,80]

print(numbers)

print(numbers[::2])                     #print alternate elements in a list  10, 30, 50, 70

print(numbers[2::2])                    #print from 2 to last with two gap, 30,50,70
```

    [10, 20, 30, 40, 50, 60, 70, 80]
    [10, 30, 50, 70]
    [30, 50, 70]
    

### Getting a List’s Length with len()
The len() function will return the number of values that are in a list value passed to it, just like it can count the number of characters in a string value. 


```python
len(spam)
```




    4




```python
lst = ['one', 'two', 'three', 'four']
                                                #find length of a list
print(len(lst))
```

    4
    

### List Count
**to count how many time element occurs in list.**


```python
numbers = [1, 2, 3, 1, 3, 4, 2, 5]

print(numbers.count(1))   #frequency of 1 in a list

print(numbers.count(3))   #frequency of 3 in a list
```

    2
    2
    

###  Changing Values in a List with Indexes
Normally a variable name goes on the left side of an assignment statement, like spam = 42. However, you can also use an index of a list to change the value at that index.


```python
spam = ['cat', 'bat', 'rat', 'elephant']
spam[1]='eagle'
spam
```




    ['cat', 'eagle', 'rat', 'elephant']




```python
spam[0]=spam[2]
spam
```




    ['rat', 'eagle', 'rat', 'elephant']



### List Concatenation and List Replication

The **+ operator** can combine two lists to create a new list value in the same way it combines two strings into a new string value.**The * operator** can also be used with a list and an integer value to replicate the list


```python
['a','b','c']+[1,2,3]
```




    ['a', 'b', 'c', 1, 2, 3]




```python
spam = ['cat', 'bat', 'rat', 'elephant']
spam+[1,2,3,4]
```




    ['cat', 'bat', 'rat', 'elephant', 1, 2, 3, 4]




```python
spam*3
```




    ['cat',
     'bat',
     'rat',
     'elephant',
     'cat',
     'bat',
     'rat',
     'elephant',
     'cat',
     'bat',
     'rat',
     'elephant']



### Removing Values from Lists with del Statements
The *del* statement will delete values at an index in a list. All of the values in the list after the deleted value will be moved up one index


```python
spam = ['cat', 'bat', 'rat', 'elephant']
del spam[0]
spam
```




    ['bat', 'rat', 'elephant']




```python
del spam[1]
spam
```




    ['bat', 'elephant']




```python
del spam[0]
spam
```




    ['elephant']



The del statement can also be used on a simple variable to delete it, as if it were an “unassignment” statement. If you try to use the variable after deleting it, you will get a NameError error because the variable no longer exists. In practice, you almost never need to delete simple variables. The delstatement is mostly used to delete values from lists.

## Working with Lists
When you first begin writing programs, it’s tempting to create many individual variables to store a group of similar values. For example, if I wanted to store the names of my cats, I might be tempted to write code like this:

    catName1 = 'Zophie'
    catName2 = 'Pooka'
    catName3 = 'Simon'
    catName4 = 'Lady Macbeth'
    catName5 = 'Fat-tail'
    catName6 = 'Miss Cleo'
    
It turns out that this is a bad way to write code. For one thing, if the number of cats changes, your program will never be able to store more cats than you have variables. These types of programs also have a lot of duplicate or nearly identical code in them. Consider how much duplicate code is in the following program.

    print('Enter the name of cat 1:')
    catName1 = input()
    print('Enter the name of cat 2:')
    catName2 = input()
    print('Enter the name of cat 3:')
    catName3 = input()
    print('Enter the name of cat 4:')
    catName4 = input()
    print('Enter the name of cat 5:')
    catName5 = input()
    print('Enter the name of cat 6:')
    catName6 = input()
    print('The cat names are:')
    print(catName1 + ' ' + catName2 + ' ' + catName3 + ' ' + catName4 + ' ' +
    catName5 + ' ' + catName6)




```python
print('Enter the name of cat 1:')
catName1 = input()
print('Enter the name of cat 2:')
catName2 = input()
print('Enter the name of cat 3:')
catName3 = input()
print('Enter the name of cat 4:')
catName4 = input()
print('Enter the name of cat 5:')
catName5 = input()
print('Enter the name of cat 6:')
catName6 = input()
print('The cat names are:')
print(catName1 + ' ' + catName2 + ' ' + catName3 + ' ' + catName4 + ' ' + catName5 + ' ' + catName6)
```

    Enter the name of cat 1:
    a
    Enter the name of cat 2:
    c
    Enter the name of cat 3:
    b
    Enter the name of cat 4:
    g
    Enter the name of cat 5:
    d
    Enter the name of cat 6:
    w
    The cat names are:
    a c b g d w
    

Instead of using multiple, repetitive variables, you can use a single variable that contains a list value. For example, here’s a new and improved version of the program. This new version uses a single list and can store any number of cats that the user types in.


```python
#written by me
catName=[]
name='s'
while name!='':
    name=input("name of the cat ''to exit:")
    catName= catName+[name]
print('cat names are')                          
print(catName)
```

    name of the cat ''to exit:ghk
    name of the cat ''to exit:jhk
    name of the cat ''to exit:
    cat names are
    ['ghk', 'jhk', '']
    


```python

catName=[]
while True:
    print('enter the name '+ str(len(catName)+1) + ' (or enter nothig to stop):')
    name=input()
    if name=='':
        break
    else:
        catName=catName+[name]
print('cat names are:')
for i in range (len(catName)):              #by using i in range
    print(catName[i])
```

    enter the name 1 (or enter nothig to stop):
    b
    enter the name 2 (or enter nothig to stop):
    k
    enter the name 3 (or enter nothig to stop):
    y
    enter the name 4 (or enter nothig to stop):
    
    cat names are:
    b
    k
    y
    


```python
catName=[]
while True:
    print('enter the name '+ str(len(catName)+1) + ' (or enter nothig to stop):')
    name=input()
    if name=='':
        break
    catName=catName+[name]
print('cat names are:') 
for i in catName:                                #using for name in catName len
    print(i)
```

    enter the name 1 (or enter nothig to stop):
    b
    enter the name 2 (or enter nothig to stop):
    k
    enter the name 3 (or enter nothig to stop):
    l
    enter the name 4 (or enter nothig to stop):
    
    cat names are:
    b
    k
    l
    

The benefit of using a list is that your data is now in a structure, so your program is much more flexible in processing the data than it would be with several repetitive variables

### Using for Loops with Lists
 Technically, a for loop repeats the code block once for each value in a list or list-like value. For example, if you ran
this code:

    for i in range(4):
        print(i)
the output of this program would be as follows:

    0
    1
    2
    3
    
This is because the return value from range(4) is a list-like value that Python considers similar to [0, 1, 2, 3]. The following program has the same output as the previous one:

    for i in [0, 1, 2, 3]:
        print(i)
        
What the previous for loop actually does is loop through its clause with the variable i set to a successive value in the
[0, 1, 2, 3] list in each iteration.


```python
for i in [0, 1, 2, 3]:
    print(i)
```

    0
    1
    2
    3
    

A common Python technique is to use range(len(someList)) with a for
loop to iterate over the indexes of a list. For example,



```python
supplies = ['pens', 'staplers', 'flame-throwers', 'binders']
for i in range(len(supplies)):
    print('Index ' + str(i) + ' in supplies is: ' + supplies[i])
```

    Index 0 in supplies is: pens
    Index 1 in supplies is: staplers
    Index 2 in supplies is: flame-throwers
    Index 3 in supplies is: binders
    

Using range(len(supplies)) in the previously shown for loop is handy because the code in the loop can access the index (as the variable i) and the value at that index (as supplies[i]). Best of all, range(len(supplies)) will iterate through all the indexes of supplies, no matter how many items it contains.

##  List comprehension


```python
# without list comprehension

squares = []
for i in range(10):
    squares.append(i**2)   #list append
print(squares)
```

    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    


```python
#using list comprehension

squares = [i**2 for i in range(10)]

print(squares)
```

    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    


```python
#example

lst = [-10, -20, 10, 20, 50]

new_lst = [i*2 for i in lst]              #create a new list with values doubled
print(new_lst)


new_lst = [i for i in lst if i >= 0]      #filter the list to exclude negative numbers
print(new_lst)



new_lst = [(i, i**2) for i in range(10)]   #create a list of tuples like (number, square_of_number)
print(new_lst)
```

    [-20, -40, 20, 40, 100]
    [10, 20, 50]
    [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)]
    

## Nested List Comprehensions



```python
#let's suppose we have a matrix

matrix = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9, 10, 11, 12]]

                                #transpose of a matrix without list comprehension
transposed = []
for i in range(4):
    lst = []
    for row in matrix:
        lst.append(row[i])
    transposed.append(lst)

print(transposed)
```

    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
    

**Using list comprehension above code can be written in one line**


```python
#with list comprehension
matrix = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9, 10, 11, 12]]

transposed = [[row[i] for row in matrix] for i in range(4)]
print(transposed)
```

    [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
    

### The in and not in Operators
You can determine whether a value is or isn’t in a list with the in and not in operators. Like other operators, in and not in are used in expressions and connect two values: a value to look for in a list and the list where it may be found. These expressions will evaluate to a Boolean value.


```python
'ram' in ['sam','jam','cam','ram']
```




    True




```python
spam=['sam','jam','cam','ram']
'cam' in spam
```




    True




```python
'cat'in spam
```




    False




```python
'mat'not in spam
```




    True



**type in a pet name and then checks to see whether the name is in a list of pets.**


```python
myPets=['don','mon','jol','sal']
print('enter pet name')
name=input()
if name in myPets:
    print(name+' is my pet')
else:
    print(name+ ' is not my pet')
```

    enter pet name
    don
    don is my pet
    

**The multiple assignment trick is a shortcut that lets you assign multiple variables with the values in a list in one line of code. So instead of doing this:**


```python
cat=['fat','black','loud']
size=cat[0]
color=cat[1]
disposion=cat[2]
```

you could type this line of code:


```python
cat=['fat','black','loud']
size,color,disposion=cat
size
```




    'fat'



**The number of variables and the length of the list must be exactly equal, or Python will give you a ValueError**:


```python
cat=['fat','black','loud']
size,color,disposion,name=cat
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-62-7510c00683e0> in <module>
          1 cat=['fat','black','loud']
    ----> 2 size,color,disposion,name=cat
    

    ValueError: not enough values to unpack (expected 4, got 3)


## Augmented Assignment Operators
Augmented Assignment Operators
When assigning a value to a variable, you will frequently use the variable
itself. For example, after assigning 42 to the variable spam, you would increase
the value in spam by 1 with the following code:


```python
spam = 42
spam = spam + 7
spam
```




    49



**As a shortcut, you can use the augmented assignment operator += to do the same thing:**


```python
spam = 42
spam += 7
spam
```




    49



**There are augmented assignment operators for the +, -, *, /, and % operators, described in Table-**

      Augmented assignment statement         Equivalent assignment statement
        spam = spam + 1                            spam += 1
        spam = spam - 1                            spam -= 1
        spam = spam * 1                            spam *= 1
        spam = spam / 1                            spam /= 1
        spam = spam % 1                            spam %= 1

The += operator can also do string and list concatenation, and the *= operator can do string and list replication




```python
spam='hello'
spam+=' world'
spam
```




    'hello world'




```python
life=['sucks']
life*=3
life
```




    ['sucks', 'sucks', 'sucks']



## Methods
Each data type has its own set of methods. The list data type, for example, has several useful methods for finding, adding, removing, andotherwise manipulating values in a list.

### Finding a Value in a List with the *index()* Method

List values have an ***index()*** method that can be passed a value, and if thatvalue exists in the list, the index of the value is returned. **If the value isn’tin the list, then Python produces a ValueError error.** Enter the following intothe interactive shell:



```python
spam=['life','living','poetry','music']
spam.index('music')
```




    3




```python
spam.index('money')
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-68-62db7f398346> in <module>
    ----> 1 spam.index('money')
    

    ValueError: 'money' is not in list



```python
spam.index('life')
```




    0




When there are duplicates of the value in the list, the index of its first appearance is returned. Enter the following into the interactive shell, and notice that **index()** **returns 1, not 4:



```python
spam=['life','music','living','poetry','music']
spam.index('music')
```




    1



### Adding Values to Lists with the *append()*,*extend()*  and *insert()* Methods

To add new values to a list, use the **append(), extend()** and **insert()** methods.



```python
spam=['life','music','living','poetry']
spam.append('money')
spam
```




    ['life', 'music', 'living', 'poetry', 'money']



The previous **append()** method call adds the argument **to the end of the list.**
The **insert()** method can insert a value **at any index** in the list. The **first argument to insert() is the index for the new value, and the second argument is the new value to be inserted.**


```python
spam=['life','music','living','poetry']
spam.insert(1,'money')
spam
```




    ['life', 'money', 'music', 'living', 'poetry']




```python
spam.insert(56,'like')
spam
```




    ['life', 'money', 'music', 'living', 'poetry', 'like']




```python
lst = ['one', 'two', 'three', 'four']

lst2 = ['five', 'six']

#append 
lst.append(lst2)

print(lst)
```

    ['one', 'two', 'three', 'four', ['five', 'six']]
    

**extend will join the list with list1**


```python
lst = ['one', 'two', 'three', 'four']

lst2 = ['five', 'six']

#extend will join the list with list1

lst.extend(lst2)

print(lst)
```

    ['one', 'two', 'three', 'four', 'five', 'six']
    

***Methods belong to a single data type. The append() and insert() methods are list methods and can be called only on list values, not on other values such as strings or integers.***


```python
eggs='hello'
eggs.append('hen')
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-76-d031586dad70> in <module>
          1 eggs='hello'
    ----> 2 eggs.append('hen')
    

    AttributeError: 'str' object has no attribute 'append'



```python
eggs=42
eggs.append('hen')
eggs
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-77-99d99c70e067> in <module>
          1 eggs=42
    ----> 2 eggs.append('hen')
          3 eggs
    

    AttributeError: 'int' object has no attribute 'append'



```python
eggs=42
eggs.insert(1,'hen')
eggs
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-78-c776bb670aa1> in <module>
          1 eggs=42
    ----> 2 eggs.insert(1,'hen')
          3 eggs
    

    AttributeError: 'int' object has no attribute 'insert'



```python
eggs=[42]
eggs.append('hen')
eggs
```




    [42, 'hen']



### Removing Values from Lists with remove(), del, pop()

The *remove()* method is passed the value to be removed from the list it is called on. Enter the following into the interactive shell:


```python
                                              #del to remove item based on index position
lst = ['one', 'two', 'three', 'four', 'five']

del lst[1]
print(lst)

                                              #or we can use pop() method
a = lst.pop(1)
print(a)

print(lst)
```

    ['one', 'three', 'four', 'five']
    three
    ['one', 'four', 'five']
    

**pop return the removed item**


```python
lst = ['one', 'two', 'three', 'four', 'five']
a = lst.pop(1)
print(a)

print(lst)
```

    two
    ['one', 'three', 'four', 'five']
    


```python
spam=['life','music','living','poetry','money']
spam.remove('money')
spam
```




    ['life', 'music', 'living', 'poetry']



**Attempting to delete a value that does not exist in the list will result in a ValueError error**


```python
spam.remove('enjoy')
spam
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-83-bcf8712c33c3> in <module>
    ----> 1 spam.remove('enjoy')
          2 spam
    

    ValueError: list.remove(x): x not in list


**If the value appears multiple times in the list, only the first instance of the value will be removed.**


```python
spam=['life','money','music','living','poetry','money']
spam.remove('money')
spam
```




    ['life', 'music', 'living', 'poetry', 'money']



### List reverse 



```python
#reverse is reverses the entire list

lst = ['one', 'two', 'three', 'four']

lst.reverse()

print(lst)
```

    ['four', 'three', 'two', 'one']
    

### List related keywords in Python


```python
#keyword 'in' is used to test if an item is in a list
lst = ['one', 'two', 'three', 'four']

if 'two' in lst:
    print('AI')

#keyword 'not' can combined with 'in'
if 'six' not in lst:
    print('ML')
```

    AI
    ML
    

### Sorting the Values in a List with the sort() Method and sorted(list) method
Lists of number values or lists of strings can be sorted with the **sort()** method.


```python
spam=['tiger','ant','bee','aan','dog','elephant','cat']
spam.sort()
spam
```




    ['aan', 'ant', 'bee', 'cat', 'dog', 'elephant', 'tiger']




```python
spam=[1,2.02,6.02,1.0,10,9]
spam.sort()
spam
```




    [1, 1.0, 2.02, 6.02, 9, 10]



1. he easiest way to sort a List is with the sorted(list) function.
2. That takes a list and returns a new list with those elements in sorted order.
3. **The original list is not changed.**
4. The sorted() optional argument reverse=True, e.g. sorted(list, reverse=True), makes it sort backwards.




```python
                                             #create a list with numbers
numbers = [3, 1, 6, 2, 8]

sorted_lst = sorted(numbers)


print("Sorted list :", sorted_lst)

                                           #original list remain unchanged
print("Original list: ", numbers)
```

    Sorted list : [1, 2, 3, 6, 8]
    Original list:  [3, 1, 6, 2, 8]
    


```python
                                            #print a list in reverse sorted order
print("Reverse sorted list :", sorted(numbers, reverse=True))

                                             #orginal list remain unchanged
print("Original list :",  numbers)
```

    Reverse sorted list : [8, 6, 3, 2, 1]
    Original list : [3, 1, 6, 2, 8]
    

**sort the list and stored in itself**


```python
lst = [1, 20, 5, 5, 4.2]

                                       #sort the list and stored in itself
lst.sort()

                                       # add element 'a' to the list to show an error

print("Sorted list: ", lst)
```

    Sorted list:  [1, 4.2, 5, 5, 20]
    


```python
lst = [1, 20, 'b', 5, 'a']
print(lst.sort()) # sort list with element of different datatypes.

```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-92-0354af416f5c> in <module>
          1 lst = [1, 20, 'b', 5, 'a']
    ----> 2 print(lst.sort()) # sort list with element of different datatypes.
    

    TypeError: '<' not supported between instances of 'str' and 'int'


**You can also pass True for the *reverse* keyword argument to have sort() sort the values in reverse order.**


```python
spam=['life','money','music','living','poetry','money']
spam.sort(reverse=True)
spam
```




    ['poetry', 'music', 'money', 'money', 'living', 'life']




```python
spam=['tiger','ant','bee','aan','dog','elephant','cat']
spam.sort(reverse=True)
spam
```




    ['tiger', 'elephant', 'dog', 'cat', 'bee', 'ant', 'aan']



**There are three things you should note about the sort() method**. 
**First**,the sort() method sorts the list in place; don’t try to capture the return value by writing code like 
*spam = spam.sort().*
**Second**, you cannot sort lists that have both number values and string values in them, since Python doesn’t know how to compare these values.Type the following into the interactive shell and notice the TypeError error:


```python
spam=[1,2,3,'kids','cat']
spam.sort()

```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-95-2b4772beda7e> in <module>
          1 spam=[1,2,3,'kids','cat']
    ----> 2 spam.sort()
    

    TypeError: '<' not supported between instances of 'str' and 'int'


**Third,** sort() uses “ASCIIbetical order” rather than actual alphabetical order for sorting strings. **This means uppercase letters come before lowercase letters**. Therefore, the lowercase a is sorted so that it comes after the uppercase Z. For an example,


```python
spam=['Ant','aam','bee','Bee','Zebra']
spam.sort()
spam
```




    ['Ant', 'Bee', 'Zebra', 'aam', 'bee']



**If you need to sort the values in regular alphabetical order, pass str. lower for the key keyword argument in the sort() method call.**
This causes the sort() function to treat all the items in the list as if they were lowercase without actually changing the values in the list.


```python
spam=['Ant','aam','bee','Bee','Zebra']
spam.sort(key=str.lower)
spam
```




    ['aam', 'Ant', 'bee', 'Bee', 'Zebra']



## Example Program: Magic 8 Ball with a List
Using lists, you can write a much more elegant version of the previous chapter’s Magic 8 Ball program. Instead of several lines of nearly identical elif statements, you can create a single list that the code works with. Open a new file editor window and enter the following code. 


```python
import random
spam=['1 is not a good choice',
      '2 relly','nice try',  
      'never loose hope',
      'you are just about to reach',
      '6 is not alwya max',
      'try your best',
      '8 goos but not tru',
      '9 bingo']
print(spam[random.randint(0,int(len(spam))-1)])
```

    you are just about to reach
    

**When you run this program, you’ll see that it works the same as the previous bellow program.**


```python
import random
def getAnswer(ans):
    if ans==1:
        return '1 is not a good choice'
    elif ans==2:
        return '2 relly'
    elif ans==3:
        return 'nice try'
    elif ans==4:
        return 'never loose hope'
    elif ans==5:
        return 'you are just about to reach'
    elif ans==6:
        return '6 is not alwya max'
    elif ans==7:
        return 'try your best'
    elif ans==8:
        return '8 goos but not tru'
    elif ans==9:
        return '9 bingo'
print(getAnswer(random.randint(1,9)))
```

    9 bingo
    

**Note:** **Exceptions to Indentation Rules in Python**

In most cases, the amount of indentation for a line of code tells Python what block it is in. There are some exceptions to this rule, however. For example, lists can actually span several lines in the source code file. The indentation of these lines do not matter; Python knows that until it sees the ending square bracket, the list is not finished. For example, you can have code that looks like this:


```python
spam = ['apples',

 'oranges',
                             'bananas',
'cats'           ]
print(spam)
```

    ['apples', 'oranges', 'bananas', 'cats']
    

Of course, practically speaking, most people use Python’s behavior to make their lists look pretty and readable, like the messages list in the Magic 8 Ball program. You can also split up a single instruction across multiple lines using the \ line continuation character at the end. Think of \ as saying, “This instruction continues on the next line.” The indentation on the line after a \ line continuation is not significant. For example, the following is valid Python code:



```python
print('Four score and seven ' + \
        'years'  +\
      'ago...')
```

    Four score and seven yearsago...
    

These tricks are useful when you want to rearrange long lines of Python code to be a bit more readable

## List-like Types: Strings and Tuples
Lists aren’t the only data types that represent ordered sequences of values. For example, strings and lists are actually similar, if you consider a string to be a “list” of single text characters. Many of the things you can do with lists can also be done with strings: indexing; slicing; and using them with for loops, with len(), and with the in and not in operators. To see this, enter the following into the interactive shell:


```python
name='pramod'
name[0]
```




    'p'




```python
name[-2]
```




    'o'




```python
name[-1]
```




    'd'




```python
name[0:3]
```




    'pra'




```python
'pr' in name
```




    True




```python
'mo'in name
```




    True




```python
'Pr'in name
```




    False




```python
for i in name:
    print(i)
```

    p
    r
    a
    m
    o
    d
    


```python
name='pramod'
for i in name:
    print('***' +i+ '****')
```

    ***p****
    ***r****
    ***a****
    ***m****
    ***o****
    ***d****
    

## Mutable and Immutable Data Types
But lists and strings are different in an important way.
**A list value is a mutable data type: It can have values added, removed, or changed.     
However,a stringis immutable: It cannot be changed.**


```python
name = 'Zophie a cat'
name[7]='the'
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-111-ed4c740b8102> in <module>
          1 name = 'Zophie a cat'
    ----> 2 name[7]='the'
    

    TypeError: 'str' object does not support item assignment


**The proper way to “mutate” a string is to use slicing and concatenation to build a new string by copying from parts of the old string**


```python
name = 'Zophie a cat'
newName=name[0:7]+'the'+name[8:12]
newName
```




    'Zophie the cat'




```python
name
```




    'Zophie a cat'



We used [0:7] and [8:12] to refer to the characters that we don’t wish to replace. Notice that the original 'Zophie a cat' string is not modified because strings are immutable. Although a list value is mutable, the second line in the following code does not modify the list eggs:


```python
eggs = [1, 2, 3]
eggs = [4, 5, 6]
eggs
```




    [4, 5, 6]



**The list value in eggs isn’t being changed here; rather, an entirely new and different list value ([4, 5, 6]) is overwriting the old list value ([1, 2, 3]).
If you wanted to actually modify the original list in eggs to contain [4, 5, 6], you would have to do something like this**


```python
eggs=[1,2,3]
del eggs[2]
del eggs[1]
del eggs[0]

eggs.append(4)
eggs.append(5)
eggs.append(6)
eggs
```




    [4, 5, 6]



Changing a value of a mutable data type (like what the del statement and append() method do in the previous example) changes the value in place, since the variable’s value is not replaced with a new list value.

## The Tuple Data Type
The tuple data type is almost identical to the list data type, except in two ways. First, tuples are typed with parentheses, ( and ), instead of square brackets, [ and ].

1. A tuple is similar to list

2. The diffence between the two is that we can't change the elements of tuple once it is assigned whereas in the list, elements can be changedor example,

**Tuple creation**


```python
name=('ram','sam','dam',5)
name[0]

```




    'ram'




```python
type(name)
```




    tuple




```python
#empty tuple
t = ()

#tuple having integers
t = (1, 2, 3)
print(t)

#tuple with mixed datatypes
t = (1, 'raju', 28, 'abc')
print(t)

#nested tuple
t = (1, (2, 3, 4), [1, 'raju', 28, 'abc'])
print(t)
```

    (1, 2, 3)
    (1, 'raju', 28, 'abc')
    (1, (2, 3, 4), [1, 'raju', 28, 'abc'])
    


```python
name[2]
```




    'dam'




```python
name[3]
```




    5




```python
name[0:2]
```




    ('ram', 'sam')




```python
name[-2]
```




    'dam'




```python
#Slicing
t = (1, 2, 3, 4, 5, 6)

print(t[1:4])

#print elements from starting to 2nd last elements
print(t[:-2])

#print elements from starting to end
print(t[:])
```

    (2, 3, 4)
    (1, 2, 3, 4)
    (1, 2, 3, 4, 5, 6)
    

**But the main way that tuples are different from lists is that tuples, like strings, are immutable. Tuples cannot have their values modified, appended, or removed.**
1. unlike lists, tuples are immutable
2. This means that elements of a tuple cannot be changed once it has been assigned. But, if the element is itself a mutable datatype like list, its nested items can be changed.


```python
name1=('ram','sam','dam',5)
name1[0]=6
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-124-635c0834c334> in <module>
          1 name1=('ram','sam','dam',5)
    ----> 2 name1[0]=6
    

    TypeError: 'tuple' object does not support item assignment



```python
#creating tuple
t = (1, 2, 3, 4, [5, 6, 7])

t[2] = 'x' #will get TypeError
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-125-1fb87c1270c4> in <module>
          2 t = (1, 2, 3, 4, [5, 6, 7])
          3 
    ----> 4 t[2] = 'x' #will get TypeError
    

    TypeError: 'tuple' object does not support item assignment



```python
t[4][1] = 'satish'
print(t)
```

    (1, 2, 3, 4, [5, 'satish', 7])
    


```python
#concatinating tuples

t = (1, 2, 3) + (4, 5, 6)
print(t)
```

    (1, 2, 3, 4, 5, 6)
    


```python
#repeat the elements in a tuple for a given number of times using the * operator.
t = (('satish', ) * 4)
print(t)
```

    ('satish', 'satish', 'satish', 'satish')
    

**If you have only one value in your tuple, you can indicate this by placing a trailing comma after the value inside the parentheses**. **Otherwise, Python will think you’ve just typed a value inside regular parentheses.** The comma is what lets Python know this is a tuple value.


```python
#nested tuple
t = ('ABC', ('satish', 'naveen', 'srinu'))

print(t[1])
```

    ('satish', 'naveen', 'srinu')
    


```python
print(t[1][2])
```

    srinu
    


```python
type(('hello'))
```




    str




```python
type(('hello',))
```




    tuple




```python
#parenthesis is optional
t = "satish", 
print(type(t))

print(t)
```

    <class 'tuple'>
    ('satish',)
    

**You can use tuples to convey to anyone reading your code that you don’t intend for that sequence of values to change.** If you need an ordered sequence of values that never changes, use a tuple. A second benefit of using tuples instead of lists is that, because they are immutable and their contents don’t change, Python can implement some optimizations that make code using tuples slightly faster than code using lists.

## Tuple Deletion
**we cannot change the elements in a tuple. That also means we cannot delete or remove items from a tuple.** delete entire tuple using del keyword



```python
#delete entire tuple using del keyword
t = (1, 2, 3, 4, 5, 6)

#delete entire tuple
del t

```

## Tuple Count
get the frequency of particular element appears in a tuple,count(element)  


```python
t = (1, 2, 3, 1, 3, 3, 4, 1)

#get the frequency of particular element appears in a tuple
t.count(1)
```




    3



## Tuple Index


```python
t = (1, 2, 3, 1, 3, 3, 4, 1)

print(t.index(3))                  #return index of the first element is equal to 3
                                #print index of the 1
```

    2
    

## Tuple Memebership
test if an item exists in a tuple or not, using the keyword in.


```python
#test if an item exists in a tuple or not, using the keyword in.
t = (1, 2, 3, 4, 5, 6)

print(1 in t)
```

    True
    


```python
print(7 in t)
```

    False
    

## Built in Functions
###  Tuple Length



```python
t = (1, 2, 3, 4, 5, 6)
print(len(t))
```

    6
    

###  Tuple Sort
you cant modify tuple,so it take elements in the tuple and return a new sorted listv(does not sort the tuple itself).


```python
t = (4, 5, 1, 2, 3)

new_t = sorted(t)
print(new_t)                   #Take elements in the tuple and return a new sorted list 
                               #(does not sort the tuple itself).
```

    [1, 2, 3, 4, 5]
    

### largest and smallest element


```python
#get the largest element in a tuple
t = (2, 5, 1, 6, 9)

print(max(t))
```

    9
    


```python
#get the smallest element in a tuple
print(min(t))
```

    1
    

### sum of elments


```python
#get sum of elments in the tuple

print(sum(t))
```

    23
    

## Converting Types with the list() and tuple() Functions

Just like how str(42) will return '42', the string representation of the integer 42, the functions list() and tuple() will return list and tuple versions of the values passed to them. 


```python
tuple([1,2,3,'cat','daog'])  #list to tuple
```




    (1, 2, 3, 'cat', 'daog')




```python
list((1, 2, 3, 'cat', 'daog'))  #tuple to list
```




    [1, 2, 3, 'cat', 'daog']



Converting a tuple to a list is handy if you need a mutable version of a tuple value.

## References



```python
spam=42
cheese=spam
spam=100
spam
```




    100




```python
cheese
```




    42




```python
id(spam)
```




    140703233912304




```python
id(cheese)
```




    140703233910448



You assign 42 to the spam variable, and then you copy the value in spam and assign it to the variable cheese. When you later change the value in spam to 100, this doesn’t affect the value in cheese. This is because spam and cheese are different variables that store different values.

**But lists don’t work this way.** When you assign a list to a variable, you are actually assigning a list ***reference*** to the variable. A *reference* is a value that points to some bit of data, and a list reference is a value that points to a list. Here is some code that will make this distinction easier to understand. 


```python
spam=[1,2,3,4,5]        #u
cheese=spam            #v 
cheese[1]='hello'       #w
spam
```




    [1, 'hello', 3, 4, 5]




```python
cheese
```




    [1, 'hello', 3, 4, 5]



The code changed only the cheese list, but it seems that both the cheese and spam lists have changed.


```python
id(spam)
```




    1883248818184




```python
id(cheese)
```




    1883248818184



   When you create the list *u*, you assign a reference to it in the spam variable. But the next line *v* copies only the list reference in spam to cheese, not the list value itself. This means the values stored in spam and cheese now both refer to the same list. There is only one underlying list because the list itself was never actually copied. So when you modify the first element of cheese *w*, you are modifying the same list that spam refers to.

   **Variables will contain references to list values rather than list values themselves. But for strings and integer values, variables simply contain the string or integer value. Python uses references whenever variables must store values of mutable data types, such as lists or dictionaries. For values of immutable data types such as strings, integers, or tuples, Python variables will store the value itself.**

### Passing References
References are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter variables. For lists (and dictionaries, which I’ll describe in the next chapter), this means a copy of the reference is used for the parameter. To see the consequences of this, open a new file editor window, enter the following code, 



```python
def egg(someParameter):
    someParameter.append('hello')
spam=[1,2,3,4,5]
egg(spam)
print(spam)
```

    [1, 2, 3, 4, 5, 'hello']
    

Notice that when eggs() is called, a return value is not used to assign a new value to spam. Instead, it modifies the list in place, directly.

Even though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned. Keep this behavior in mind: Forgetting that Python handles list anddictionary variables this way can lead to confusing bugs.

### The *copy* Module’s *copy()* and *deepcopy()* Functions

Although passing around references is often the handiest way to deal withlists and dictionaries, if the function modifies the list or dictionary that is passed, you may not want these changes in the original list or dictionary value.

 For this, Python provides a module named **copy** that provides both the **copy()** and **deepcopy()** functions. The first of these, **copy.copy()**, can be ***used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference.***


```python
import copy
spam=[1,2,3,5,4,'life']
cheese=copy.copy(spam)
cheese[1]='YoYo'
cheese
```




    [1, 'YoYo', 3, 5, 4, 'life']




```python
spam
```




    [1, 2, 3, 5, 4, 'life']



**If the *list you need to copy contains lists*, then use the copy.deepcopy() function instead of copy.copy(). The deepcopy() function will copy these inner lists as well.**

## Summary
Lists are useful data types since they allow you to write code that works on a modifiable number of values in a single variable. Later in this book, you will see programs using lists to do things that would be difficult or impossible to do without them.

Lists are mutable, meaning that their contents can change. Tuples and strings, although list-like in some respects, are immutable and cannot be changed. A variable that contains a tuple or string value can be overwritten with a new tuple or string value, but this is not the same thing as modifying the existing value in place—like, say, the append() or remove() methods do on lists.

Variables do not store list values directly; they store references to lists. This is an important distinction when copying variables or passing lists as arguments in function calls. Because the value that is being copied is the list reference, be aware that any changes you make to the list might impact another variable in your program. You can use copy() or deepcopy() if you want to make changes to a list in one variable without modifying the original list

## Practice Projects

### Comma Code

Say you have a list value like this:

    spam = ['apples', 'bananas', 'tofu', 'cats']

Write a function that takes a list value as an argument and returns a string with all the items separated by a comma and a space, with and inserted before the last item. For example, passing the previous spam list to the function would return *'apples, bananas, tofu, and cats'*. But your function should be able to work with any list value passed to it.


```python
def commaCode(spam):
    spam2=''
    for i in range (len(spam)-1):  
        str(spam[i])
        spam2=spam2+str(spam[i])+','
    for i in range (len(spam)-1, len(spam)):
        spam2=spam2+'and '+ str(spam[i])
    return print(spam2)
s=[1,2,3,'cat','dog']
commaCode(s)
```

    1,2,3,cat,and dog
    


```python
def commaCode(spam):                                 #define function for commaCode
    spam2=''
    for i in range (len(spam)-1):  
        str(spam[i])
        spam2=spam2+str(spam[i])+','
    for i in range (len(spam)-1, len(spam)):
        spam2=spam2+'and '+ str(spam[i])
    return print(spam2)
n=int(input('lenth of stirng: '))

s=[]                                             #to enter the list elements
for i in range (n):
    print('enter '+str(i)+ 'th value')
    valu=input()
    s.append(valu)
print('list is:', s)

                                                 #commaCode to print in comma formate
print('list in commaCode is:')
commaCode(s)
```

    lenth of stirng: 5
    enter 0th value
    man
    enter 1th value
    tan
    enter 2th value
    ran
    enter 3th value
    lan
    enter 4th value
    wan
    list is: ['man', 'tan', 'ran', 'lan', 'wan']
    list in commaCode is:
    man,tan,ran,lan,and wan
    

### Character Picture Grid

Say you have a list of lists where each value in the inner lists is a one-character string, like this:

    grid = [['.', '.', '.', '.', '.', '.'],
            ['.', 'O', 'O', '.', '.', '.'],
            ['O', 'O', 'O', 'O', '.', '.'],
            ['O', 'O', 'O', 'O', 'O', '.'],
            ['.', 'O', 'O', 'O', 'O', 'O'],
            ['O', 'O', 'O', 'O', 'O', '.'],
            ['O', 'O', 'O', 'O', '.', '.'],
            ['.', 'O', 'O', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.']]
    
You can think of grid[x][y] as being the character at the x- and y-coordinates of a “picture” drawn with text characters. The (0, 0) origin will be in the upper-left corner, the x-coordinates increase going right, and w the y-coordinates increase going down. Copy the previous grid value, and write code that uses it to print the image.

    ..OO.OO..
    .OOOOOOO.
    .OOOOOOO.
    ..OOOOO..
    ...OOO...
    ....O....
    
Hint: You will need to use a loop in a loop in order to print grid[0][0], then grid[1][0], then grid[2][0], and so on, up to grid[8][0]. This will finish the first row, so then print a newline. Then your program should print grid[0][1], then grid[1][1], then grid[2][1], and so on. The last thing your program will print is grid[8][5]. Also, remember to pass the end keyword argument to print() if you don’t want a newline printed automatically after each print() call.


```python
grid = [['.', '.', '.', '.', '.', '.'],
        ['.', 'O', 'O', '.', '.', '.'],
        ['O', 'O', 'O', 'O', '.', '.'],
        ['O', 'O', 'O', 'O', 'O', '.'],
        ['.', 'O', 'O', 'O', 'O', 'O'],
        ['O', 'O', 'O', 'O', 'O', '.'],
        ['O', 'O', 'O', 'O', '.', '.'],
        ['.', 'O', 'O', '.', '.', '.'],
        ['.', '.', '.', '.', '.', '.']]
for i in range (6):
    for j in range (9):
        print (grid[j][i],end='')
    print('')
```

    ..OO.OO..
    .OOOOOOO.
    .OOOOOOO.
    ..OOOOO..
    ...OOO...
    ....O....
    

# Sets
1. A set is an **unordered** collection of items. Every element **is unique (no duplicates)**.
2. The set itself is **mutable**. We can add or remove items from it.
3. can be used to **perform mathematical set operations** like union, intersection, symmetric difference etc.

## Set Creation
created using curly braces {}


```python
#set of integers
s = {1, 2, 3}

print(s)
print(type(s))   #print type of s 
```

    {1, 2, 3}
    <class 'set'>
    


```python
#set doesn't allow duplicates. They store only one instance.

s = {1, 2, 3, 1, 4}
print(s)
```

    {1, 2, 3, 4}
    

**we can make set from a list**,by using *set([list elements])*


```python
#we can make set from a list

s = set([1, 2, 3, 1])
print(s)
```

    {1, 2, 3}
    


```python
#initialize a set  with set() method

s = set()
print(type(s))
```

    <class 'set'>
    

## Add element to a Set
1. we can add single element using **add()** method and 
2. add multiple elements using **update()** method
3. set object doesn't support indexing, will get TypeError


```python
s = {1, 3}
                         #set object doesn't support indexing
print(s[1])              #will get TypeError
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-164-9a30584168ac> in <module>
          1 s = {1, 3}
          2                          #set object doesn't support indexing
    ----> 3 print(s[1])              #will get TypeError
    

    TypeError: 'set' object is not subscriptable



```python
#add element
s = {1, 3}

s.add(2)
print(s)
```

    {1, 2, 3}
    


```python
#add multiple elements

s.update([5, 6, 1])
print(s)
```

    {1, 2, 3, 5, 6}
    


```python
#add list and set

s.update([8, 9], {10, 2, 3})
print(s)
```

    {1, 2, 3, 5, 6, 8, 9, 10}
    

## Remove elements from a Set
1. A particular item can be removed from set using methods, **discard() and remove().**
2. we can remove item using **pop()** method,it will **remove random element**
3. Remove all items in set using **clear()** method


```python
s = {1, 2, 3, 5, 4}
print(s)

s.discard(4)    #4 is removed from set s
print(s)
```

    {1, 2, 3, 4, 5}
    {1, 2, 3, 5}
    


```python
#remove an element 
s.remove(2)

print(s)
```

    {1, 3, 5}
    


```python
#remove an element not present in a set s

s.remove(7) # will get KeyError
```


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    <ipython-input-170-f0f5859d0435> in <module>
          1 #remove an element not present in a set s
          2 
    ----> 3 s.remove(7) # will get KeyError
    

    KeyError: 7



```python
#discard an element not present in a set s

s.discard(7)
print(s)
```

    {1, 3, 5}
    


```python
#we can remove item using pop() method
s = {1, 2, 3, 5, 4}

s.pop()                   #remove random element
print(s)
```

    {2, 3, 4, 5}
    


```python
s.pop() 
print(s)
```

    {3, 4, 5}
    


```python
s = {1, 5, 2, 3, 6}

s.clear()   #remove all items in set using clear() method

print(s)
```

    set()
    

## Python Set Operations
1. **union:** using | operator, or  set1.union(set2)
2. **intersection:** using & operator, or set1.intersection(set2)
3. **Difference:** using - operator, or set1.difference(set2)
4. **symmetric difference:** set of elements in both set1 and set2 except those that are common in both: use ^ operator (set1^set2),or set1.symmetric_difference(set2)
5. **chech for subset:** issubset() eg:''x.issubset(y))'' to check x is subset of y


```python
set1 = {1, 2, 3, 4, 5}
set2 = {3, 4, 5, 6, 7}

#union of 2 sets using | operator

print(set1 | set2)
```

    {1, 2, 3, 4, 5, 6, 7}
    


```python
#another way of getting union of 2 sets

print(set1.union(set2))
```

    {1, 2, 3, 4, 5, 6, 7}
    


```python
intersection#intersection of 2 sets using & operator

print(set1 & set2)
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-177-23a10fdba537> in <module>
    ----> 1 intersection#intersection of 2 sets using & operator
          2 
          3 print(set1 & set2)
    

    NameError: name 'intersection' is not defined



```python
#use intersection function 

print(set1.intersection(set2))
```

    {3, 4, 5}
    


```python
#set Difference: set of elements that are only in set1 but not in set2

print(set1 - set2)
```

    {1, 2}
    


```python
#use differnce function 

print(set1.difference(set2))
```

    {1, 2}
    


```python
"""symmetric difference: set of elements in both set1 and set2 
#except those that are common in both."""

#use ^ operator

print(set1^set2)
```

    {1, 2, 6, 7}
    


```python
#use symmetric_difference function

print(set1.symmetric_difference(set2))
```

    {1, 2, 6, 7}
    


```python
#find issubset()
x = {"a","b","c","d","e"}
y = {"c","d"}

print("set 'x' is subset of 'y' ?", x.issubset(y))   #check x is subset of y

print("set 'y' is subset of 'x' ?", y.issubset(x))  #check y is subset of x
```

    set 'x' is subset of 'y' ? False
    set 'y' is subset of 'x' ? True
    

## Frozen Sets
1. Frozen sets has the **characteristics of sets**, but **we can't be changed once it's assigned.** While tuple are immutable lists, **frozen sets are immutable sets.**

2. Frozensets can be created using the function **frozenset()**

3. **Sets being mutable are unhashable, so they can't be used as dictionary keys**. On the other hand, **frozensets are hashable and can be used as keys to a dictionary.**

4. This datatype supports methods like **copy(), difference(), intersection(), isdisjoint(), issubset(), issuperset(), symmetric_difference() and union().** Being **immutable it does not have method that add or remove elements.**


```python
set1 = frozenset([1, 2, 3, 4])
set2 = frozenset([3, 4, 5, 6])

                                        #try to add element into set1 gives an error
set1.add(5)
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-184-91446590e838> in <module>
          3 
          4                                         #try to add element into set1 gives an error
    ----> 5 set1.add(5)
    

    AttributeError: 'frozenset' object has no attribute 'add'



```python
print(set1[1])                  # frozen set doesn't support indexing
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-185-1b025a0aa499> in <module>
    ----> 1 print(set1[1])                  # frozen set doesn't support indexing
    

    TypeError: 'frozenset' object is not subscriptable



```python
                       #intersection of two sets
print(set1 & set2)

             #or 
print(set1.intersection(set2))
```

    frozenset({3, 4})
    frozenset({3, 4})
    


```python
#symmetric difference
print(set1 ^ set2)

#or
print(set1.symmetric_difference(set2))
```

    frozenset({1, 2, 5, 6})
    frozenset({1, 2, 5, 6})
    

# Dictionaries and Structuring Data



In this chapter, I will cover the dictionary data type, which provides a flexible way to access and organize data. Then, combining dictionaries with your knowledge of lists from the previous chapter, you’ll learn how to create a data structure to model a tic-tac-toe board.

Python dictionary is an unordered collection of items. While other compound data types have only value as an element, a dictionary has a key: value pair.

## The Dictionary Data Type
Like a list, a *dictionary* is a collection of many values. But unlike *indexes* for lists, indexes for dictionaries can use many different data types, not just integers. Indexes for dictionaries are called *keys*, and a key with its associated value is called a *key-value pair*.
**In code, a dictionary is typed with braces, {}**


```python
myCat={'size':'fat','color':'grey','disposition': 'loud'}
myCat['size']
```




    'fat'




```python
myCat['color']
```




    'grey'




```python
'my cat has '+myCat['color']+ ' fur'
```




    'my cat has grey fur'




```python
#empty dictionary
my_dict = {}

#dictionary with integer keys
my_dict = {1: 'abc', 2: 'xyz'}
print(my_dict)

#dictionary with mixed keys
my_dict = {'name': 'satish', 1: ['abc', 'xyz']}
print(my_dict)


#create empty dictionary using dict()
my_dict = dict()

my_dict = dict([(1, 'abc'), (2, 'xyz')])                           #create a dict with list of tuples
print(my_dict)
```

    {1: 'abc', 2: 'xyz'}
    {'name': 'satish', 1: ['abc', 'xyz']}
    {1: 'abc', 2: 'xyz'}
    

**Dictionaries can still use integer values as keys, just like lists use integers for indexes, but they do not have to start at and can be any number.**


```python
spam={1234:'luggage combination',42:'the answer'}
spam[1234]
```




    'luggage combination'




```python
my_dict = {'name': 'satish', 'age': 27, 'address': 'guntur'}

#get name
print(my_dict['name'])
```

    satish
    


```python
#if key is not present it gives KeyError

print(my_dict['degree'])
```


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    <ipython-input-194-235a293ee8a6> in <module>
          1 #if key is not present it gives KeyError
          2 
    ----> 3 print(my_dict['degree'])
    

    KeyError: 'degree'



```python
#another way of accessing key

print(my_dict.get('address'))
```

    guntur
    


```python
#if key is not present it will give None using get method

print(my_dict.get('degree'))
```

    None
    


```python

```

### Dictionaries vs. Lists

Unlike lists, **items in dictionaries are unordered.** The first item in a list named spam would be spam[0]. But **there is no “first” item in a dictionary.** While the order of items matters for determining whether two lists are the same, it does not matter in what order the key-value pairs are typed in a dictionary. 


```python
spam=['cat','rat','eagle']
baccon=['rat','eagle','cat']
spam==baccon
```




    False




```python
eggs={'name':'l','class':8, 'age':17}
ham={'age':17,'name':'l','class':8}
eggs==ham
```




    True



**Because dictionaries are not ordered, they can’t be sliced like lists.**
Trying to access a key that does not exist in a dictionary will result in a KeyError error message, much like a list’s “out-of-range” IndexError error message


```python
eggs={'name':'l','class':8, 'age':17}
eggs['color']
```


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    <ipython-input-199-1f58d46d3c36> in <module>
          1 eggs={'name':'l','class':8, 'age':17}
    ----> 2 eggs['color']
    

    KeyError: 'color'



```python
eggs={'name':'l','class':8, 'age':17}
eggs['color']=52
eggs
```




    {'name': 'l', 'class': 8, 'age': 17, 'color': 52}




```python
birthday={'riya':'dec 4','saloni':'nov 4','pramod':'oct 26'}          # initial dictionary and store it in birthdays
while True:
    print('enter name,(keep blank to quit)')
    name=input()                            #if the entered name exists as a key in the dictionary with the in keyword
    if name=='':
        break
    if name in birthday:
        print('bithday of '+ name+ ' is on'+ birthday[name])
    else:
        print('birhday info cant find in database')
        bday=input()
        birthday[name]=bday                                                   #entering new data in dictionary
        print('bday data base updated')
print(birthday)                                                               #optional to see updated list
        
```

    enter name,(keep blank to quit)
    riya
    bithday of riya is ondec 4
    enter name,(keep blank to quit)
    pky
    birhday info cant find in database
    5sep
    bday data base updated
    enter name,(keep blank to quit)
    pky
    bithday of pky is on5sep
    enter name,(keep blank to quit)
    
    {'riya': 'dec 4', 'saloni': 'nov 4', 'pramod': 'oct 26', 'pky': '5sep'}
    

**Of course, all the data you enter in this program is forgotten when the program terminates. You’ll learn how to save data to files on the hard drive in Chapter 8.**


### The *keys(), values()*, and *items()* Methods

   There are three dictionary methods that will return list-like values of the dictionary’s keys, values, or both keys and values: *keys(), values()*, and *items()*. The values returned by these methods are not true lists: They cannot be modified and do not have an *append()* method. But these data types (dict_keys,dict_values, and dict_items, respectively) can be used in for loops. To see how these methods work, enter the following into the interactive shell:


```python
spam = {'color': 'red', 'age': 42}
for v in spam.values():
    print(v)
```

    red
    42
    


```python
spam.values()
```




    dict_values(['red', 42])



**Here, a for loop iterates over each of the values in the spam dictionary. A for loop can also iterate over the keys or both keys and values:**


```python
for k in spam.keys():
    print(k)
```

    color
    age
    


```python
for i in spam.items():
    print(i)
```

    ('color', 'red')
    ('age', 42)
    

**Notice that the values in the dict_items value returned by the items() method aretuples of the key and value. If you want a true list from one of these methods, pass its list-like return value to the list() function.** Enter the following into the interactive shell:


```python
spam = {'color': 'red', 'age': 42}
spam.keys()
```




    dict_keys(['color', 'age'])




```python
list(spam.keys())
```




    ['color', 'age']



**You can also use the multiple assignment trick in a for loop to assign the key and value to separate variables. Enter the following into the interactive shell:**


```python
spam = {'color': 'red', 'age': 42}
for k,v in spam.items():
    print('key: '+k+'  value: '+str(v))
```

    key: color  value: red
    key: age  value: 42
    

### Checking Whether a *Key* or *Value* Exists in a Dictionary
Recall from the previous chapter that the in and not in operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary. Enter the following into the interactive shell:


```python
spam = {'name': 'Zophie', 'age': 7}
'name' in spam.keys()
```




    True




```python
'name' in spam
```




    True




```python
'age' in spam
```




    True




```python
'age' in spam.values()
```




    False




```python
'age' not in spam.values()
```




    True




```python
7 in spam.values()
```




    True



### The get() Method
 get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.



```python
picnicItems = {'apples': 5, 'cups': 2}
picnicItems.get('cups',0)
```




    2




```python
picnicItems.get('apple',0)
```




    0




```python
'i am bringing '+ str(picnicItems.get('cups',0))+ ' cups'
```




    'i am bringing 2 cups'




```python
'i am bringing '+ str(picnicItems.get('apple',0))+ ' apple'
```




    'i am bringing 0 apple'



Because there is no 'apple' key in the picnicItems dictionary, the default value 0 is returned by the get() method. Without using get(), the code would have caused an error message, such as in the following example:



```python
'i am bringing '+ str(picnicItems['apple'])+ ' apple'
```


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    <ipython-input-220-439bc887f795> in <module>
    ----> 1 'i am bringing '+ str(picnicItems['apple'])+ ' apple'
    

    KeyError: 'apple'



```python
picnicItems = {'apples': 5, 'cups': 2}
picnicItems.get('cups')
```




    2




```python
print(picnicItems.get('name'))
```

    None
    



### The setdefault() Method



You’ll often have to set a value in a dictionary for a certain key only if that key does not already have a value. The code looks something like this:


```python
spam={'name':'pooka','age':5}
if 'color' not in spam:
    spam['color']='black'
spam
```




    {'name': 'pooka', 'age': 5, 'color': 'black'}



The **setdefault()** method offers a way to do this in one line of code. The **first argument passed to the method is the key** to check for, and the **second argument is the value to set at that key** **if the key does not exist.** If the key does exist, the setdefault() method returns the key’s value.


```python
spam={'name':'pooka','age':5}
spam.setdefault('color','black')
spam
```




    {'name': 'pooka', 'age': 5, 'color': 'black'}




```python
spam.setdefault('color','white')
spam
```




    {'name': 'pooka', 'age': 5, 'color': 'black'}



The first time *setdefault()* is called, the dictionary in spam changes to *{'color': 'black', 'age': 5, 'name': 'Pooka'}.* The method returns the value *'black'* because this is now the value set for the key 'color'. When *spam.setdefault('color', 'white')* is called next, the value for that key is **not changed to 'white' because spam already has a key named 'color'.**

The **setdefault()** method is a nice shortcut to ensure that a key exists. **Here is a short program that counts the number of occurrences of each letter in a string**. Open the file editor window and enter the following code, 


```python
message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
count={}
for character in message:
    count.setdefault(character,0)
    count[character]=count[character]+1
print(count)
```

    {'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}
    


```python
message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
count={}
for i in message:
    count.setdefault(i,0)
    count[i]=count[i]+1
print(count)
```

    {'I': 1, 't': 6, ' ': 13, 'w': 2, 'a': 4, 's': 3, 'b': 1, 'r': 5, 'i': 6, 'g': 2, 'h': 3, 'c': 3, 'o': 2, 'l': 3, 'd': 3, 'y': 1, 'n': 4, 'A': 1, 'p': 1, ',': 1, 'e': 5, 'k': 2, '.': 1}
    

The program loops over each character in the message variable’s string, counting how often each character appears. The setdefault() method call ensures that the key is in the count dictionary (with a default value of 0) so the program doesn’t throw a KeyError error when *count[character] = count[character] + 1* is executed. 

From the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time. This program will work no matter what string is inside the message variable, even if the string is millions of characters long!

## Dict Add or Modify Elements


```python
my_dict = {'name': 'satish', 'age': 27, 'address': 'guntur'}
                                                                  #update name 
my_dict['name'] = 'raju'

print(my_dict)
```

    {'name': 'raju', 'age': 27, 'address': 'guntur'}
    


```python
                                                               #add new key
my_dict['degree'] = 'M.Tech'

print(my_dict)
```

    {'name': 'raju', 'age': 27, 'address': 'guntur', 'degree': 'M.Tech'}
    

##  Dict Delete or Remove Element


```python
#create a dictionary
my_dict = {'name': 'satish', 'age': 27, 'address': 'guntur'}

                                            #remove a particular item
print(my_dict.pop('age'))

print(my_dict)
```

    27
    {'name': 'satish', 'address': 'guntur'}
    


```python
my_dict = {'name': 'satish', 'age': 27, 'address': 'guntur'}

                                            #remove an arbitarty key
my_dict.popitem()

print(my_dict)
```

    {'name': 'satish', 'age': 27}
    


```python
squares = {2: 4, 3: 9, 4: 16, 5: 25}

                                               #delete particular key
del squares[2]

print(squares)
```

    {3: 9, 4: 16, 5: 25}
    


```python
                                            #remove all items
squares.clear()

print(squares)
```

    {}
    


```python
squares = {2: 4, 3: 9, 4: 16, 5: 25}

                                             #delete dictionary itself
del squares

print(squares) #NameError because dict is deleted
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-234-eea9242ff699> in <module>
          4 del squares
          5 
    ----> 6 print(squares) #NameError because dict is deleted
    

    NameError: name 'squares' is not defined


## Dictionary Methods


```python
squares = {2: 4, 3: 9, 4: 16, 5: 25}

my_dict = squares.copy()
print(my_dict)
```

    {2: 4, 3: 9, 4: 16, 5: 25}
    


```python
      #fromkeys[seq[, v]] -> Return a new dictionary with keys from seq and value equal to v (defaults to None).


subjects = {}.fromkeys(['Math', 'English', 'Hindi'], 0)

print(subjects)
```

    {'Math': 0, 'English': 0, 'Hindi': 0}
    


```python
subjects = {2:4, 3:9, 4:16, 5:25}
print(subjects.items())               #return a new view of the dictionary items (key, value)
```

    dict_items([(2, 4), (3, 9), (4, 16), (5, 25)])
    


```python
subjects = {2:4, 3:9, 4:16, 5:25}
print(subjects.keys())                  #return a new view of the dictionary keys
```

    dict_keys([2, 3, 4, 5])
    


```python
#get list of all available methods and attributes of dictionary
d = {}
print(dir(d))
```

    ['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
    

## Dict Comprehension


```python
#Dict comprehensions are just like list comprehensions but for dictionaries

d = {'a': 1, 'b': 2, 'c': 3}
for pair in d.items():
    print(pair)
```

    ('a', 1)
    ('b', 2)
    ('c', 3)
    


```python
#Creating a new dictionary with only pairs where the value is larger than 2

d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}

new_dict = {k:v for k, v in d.items() if v > 2}
print(new_dict)
```

    {'c': 3, 'd': 4}
    


```python
#We can also perform operations on the key value pairs

d = {'a':1,'b':2,'c':3,'d':4,'e':5}

d = {k + 'c':v * 2 for k, v in d.items() if v > 2}
print(d)
```

    {'cc': 6, 'dc': 8, 'ec': 10}
    

## Pretty Printing
If you **import the pprint** module into your programs, you’ll have access to the **pprint()** and **pformat()** functions that will **“pretty print”** a dictionary’s values. This is helpful when you want a cleaner display of the items in a dictionary than what print() provides.


```python
message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
import pprint
count={}
for character in message:
    count.setdefault(character,0)
    count[character]=count[character]+1
    
pprint.pprint(count)           #or print(pprint.pformat(count))
```

    {' ': 13,
     ',': 1,
     '.': 1,
     'A': 1,
     'I': 1,
     'a': 4,
     'b': 1,
     'c': 3,
     'd': 3,
     'e': 5,
     'g': 2,
     'h': 3,
     'i': 6,
     'k': 2,
     'l': 3,
     'n': 4,
     'o': 2,
     'p': 1,
     'r': 5,
     's': 3,
     't': 6,
     'w': 2,
     'y': 1}
    

The pprint.pprint() function is especially helpful when the dictionary itself contains nested lists or dictionaries. If you want to obtain the prettified text as a string value instead of displaying it on the screen, call pprint.pformat() instead. These two lines are equivalent to each other:

    pprint.pprint(someDictionaryValue)
    print(pprint.pformat(someDictionaryValue))


```python
message = 'It was a bright cold day in April, and the clocks were striking thirteen.'
count={}
for i in message:
    count.setdefault(i,0)
    count[i]=count[i]+1
print(pprint.pformat(count)) #or pprint.pprint(count) 
```

    {' ': 13,
     ',': 1,
     '.': 1,
     'A': 1,
     'I': 1,
     'a': 4,
     'b': 1,
     'c': 3,
     'd': 3,
     'e': 5,
     'g': 2,
     'h': 3,
     'i': 6,
     'k': 2,
     'l': 3,
     'n': 4,
     'o': 2,
     'p': 1,
     'r': 5,
     's': 3,
     't': 6,
     'w': 2,
     'y': 1}
    

## Using Data Structures to Model Real-World Things

Even before the Internet, it was possible to play a game of chess with someone on the other side of the world. Each player would set up a chessboard at their home and then take turns mailing a postcard to each other describing each move. To do this, the players needed a way to unambiguously describe the state of the board and their moves.

In algebraic chess notation, the spaces on the chessboard are identified by a number and letter coordinate, as in Figure

![Image of chess](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b6/SCD_algebraic_notation.svg/242px-SCD_algebraic_notation.svg.png)

The chess pieces are identified by letters: **K for king, Q for queen, R for rook, B for bishop, and N for knight**. Describing a move uses the letter of the piece and the coordinates of its destination. A pair of these moves describes what happens in a single turn (with white going first); for instance, the notation 2. Nf3 Nc6 indicates that white moved a knight to f3 and black
moved a knight to c6 on the second turn of the game. There’s a bit more to algebraic notation than this, but the point is that
you can use it to unambiguously describe a game of chess without needing to be in front of a chessboard. Your opponent can even be on the other side of the world! In fact, you don’t even need a physical chess set if you have a good memory: You can just read the mailed chess moves and update boards you have in your imagination. Computers have good memories. A program on a modern computer can easily store billions of strings like '2. Nf3 Nc6'. This is how computers can
play chess without having a physical chessboard. They model data to represent a chessboard, and you can write code to work with this model. This is where lists and dictionaries can come in. You can use them to model real-world things, like chessboards. For the first example, you’ll use a game that’s a little simpler than chess: **tic-tac-toe.** 

### A Tic-Tac-Toe Board
A tic-tac-toe board looks like a large hash symbol (#) with nine slots that can each contain an X, an O, or a blank. To represent the board with a dictionary, you can assign each slot a string-value key, as shown in Figure
![image of tic tac toe](https://automatetheboringstuff.com/images/000003.png)
You can use string values to represent what’s in each slot on the board: 'X', 'O', or ' ' (a space character). Thus, you’ll need to store nine strings. You can use a dictionary of values for this. The string value with the key 'top-R' can represent the top-right corner, the string value with the key 'low-L' can represent the bottom-left corner, the string value with the key 'mid-M' can represent the middle, and so on.
This dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named theBoard. Open a new file editor window, and enter the following source code, 


```python
theBoard={'t-l':' ','t-M':' ','t-r':' ',
          'm-L':' ','m-M':' ','m-R':' ',
          'l-L':' ','l-M':' ','l-R':' '}
#The data structure stored in the theBoard variable represents the tic-tactoe board in Figure
```

 **Let’s create a function to print the board dictionary onto the screen.**


```python
theBoard={'t-L':' ','t-M':' ','t-R':' ',
          'm-L':' ','m-M':' ','m-R':' ',
          'l-L':' ','l-M':' ','l-R':' '}


def printBoard(board):
    print(board['t-L']+'|'+board['t-M']+'|'+board['t-R'])
    print('-+-+-')
    print(board['m-L']+'|'+board['m-M']+'|'+board['m-R'])
    print('-+-+-')
    print(board['l-L']+'|'+board['l-M']+'|'+board['l-R'])
    
    
printBoard(theBoard)
```

     | | 
    -+-+-
     | | 
    -+-+-
     | | 
    




```python
theBoard={'t-L':'o','t-M':'o','t-R':'o',
          'm-L':'x','m-M':'x','m-R':' ',
          'l-L':' ','l-M':' ','l-R':'x'}


def printBoard(board):
    print(board['t-L']+'|'+board['t-M']+'|'+board['t-R'])
    print('-+-+-')
    print(board['m-L']+'|'+board['m-M']+'|'+board['m-R'])
    print('-+-+-')
    print(board['l-L']+'|'+board['l-M']+'|'+board['l-R'])
    
    
printBoard(theBoard)
```

    o|o|o
    -+-+-
    x|x| 
    -+-+-
     | |x
    

the **printBoard()** function expects the tic-tac-toe data structure to be a dictionary with keys for all nine slots. If the dictionary you passed was **missing,** say, the **'m-M'** key, your program would no longer work


```python
theBoard={'t-L':' ','t-M':' ','t-R':' ',
          'm-L':' ','m-R':' ',
          'l-L':' ','l-M':' ','l-R':' '}


def printBoard(board):
    print(board['t-L']+'|'+board['t-M']+'|'+board['t-R'])
    print('-+-+-')
    print(board['m-L']+'|'+board['m-M']+'|'+board['m-R'])
    print('-+-+-')
    print(board['l-L']+'|'+board['l-M']+'|'+board['l-R'])
    
    
printBoard(theBoard)
```

     | | 
    -+-+-
    


    ---------------------------------------------------------------------------

    KeyError                                  Traceback (most recent call last)

    <ipython-input-248-7f3bd54f6d08> in <module>
         12 
         13 
    ---> 14 printBoard(theBoard)
    

    <ipython-input-248-7f3bd54f6d08> in printBoard(board)
          7     print(board['t-L']+'|'+board['t-M']+'|'+board['t-R'])
          8     print('-+-+-')
    ----> 9     print(board['m-L']+'|'+board['m-M']+'|'+board['m-R'])
         10     print('-+-+-')
         11     print(board['l-L']+'|'+board['l-M']+'|'+board['l-R'])
    

    KeyError: 'm-M'


**Now let’s add code that allows the players to enter their moves.**


```python
theBoard={'t-L':' ','t-M':' ','t-R':' ',
          'm-L':' ','m-M':' ','m-R':' ',
          'l-L':' ','l-M':' ','l-R':' '}


def printBoard(board):
    print(board['t-L']+'|'+board['t-M']+'|'+board['t-R'])
    print('-+-+-')
    print(board['m-L']+'|'+board['m-M']+'|'+board['m-R'])
    print('-+-+-')
    print(board['l-L']+'|'+board['l-M']+'|'+board['l-R'])
    
turn='x'
for i in range(9):
    printBoard(theBoard)
    print('turn for player '+turn+' move which space')
    move=input()
    theBoard[move]=turn
    if turn=='x':
        turn='o'
    else:
        turn='x'
printBoard(theBoard)
```

     | | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    t-L
    x| | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player o move which space
    t-M
    x|o| 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    t-L
    x|o| 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player o move which space
    t-R
    x|o|o
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    m-R
    x|o|o
    -+-+-
     | |x
    -+-+-
     | | 
    turn for player o move which space
    m-M
    x|o|o
    -+-+-
     |o|x
    -+-+-
     | | 
    turn for player x move which space
    m-L
    x|o|o
    -+-+-
    x|o|x
    -+-+-
     | | 
    turn for player o move which space
    l-L
    x|o|o
    -+-+-
    x|o|x
    -+-+-
    o| | 
    turn for player x move which space
    l-M
    x|o|o
    -+-+-
    x|o|x
    -+-+-
    o|x| 
    

**This isn’t a complete tic-tac-toe game—for instance, it doesn’t ever check whether a player has won—but it’s enough to see how data structures can be used in programs.**


```python
theBoard={'7':' ','8':' ','9':' ',
          '4':' ','5':' ','6':' ',
          '1':' ','2':' ','3':' '}


def printBoard(board):
    print(board['7']+'|'+board['8']+'|'+board['9'])
    print('-+-+-')
    print(board['4']+'|'+board['5']+'|'+board['6'])
    print('-+-+-')
    print(board['1']+'|'+board['2']+'|'+board['3'])
    
turn='x'
for i in range(9):
    printBoard(theBoard)
    print('turn for player '+turn+' move which space')
    move=input()
    theBoard[move]=turn
    if turn=='x':
        turn='o'
    else:
        turn='x'
        
printBoard(theBoard)
```

     | | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    7
    x| | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player o move which space
    8
    x|o| 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    9
    x|o|x
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player o move which space
    5
    x|o|x
    -+-+-
     |o| 
    -+-+-
     | | 
    turn for player x move which space
    6
    x|o|x
    -+-+-
     |o|x
    -+-+-
     | | 
    turn for player o move which space
    1
    x|o|x
    -+-+-
     |o|x
    -+-+-
    o| | 
    turn for player x move which space
    2
    x|o|x
    -+-+-
     |o|x
    -+-+-
    o|x| 
    turn for player o move which space
    3
    x|o|x
    -+-+-
     |o|x
    -+-+-
    o|x|o
    turn for player x move which space
    4
    x|o|x
    -+-+-
    x|o|x
    -+-+-
    o|x|o
    


```python
theBoard={'7':' ','8':' ','9':' ',
          '4':' ','5':' ','6':' ',
          '1':' ','2':' ','3':' '}


def printBoard(board):
    print(board['7']+'|'+board['8']+'|'+board['9'])
    print('-+-+-')
    print(board['4']+'|'+board['5']+'|'+board['6'])
    print('-+-+-')
    print(board['1']+'|'+board['2']+'|'+board['3'])
    
turn='x'
numberOfMove=0
for i in range(9):
    printBoard(theBoard)
    print('turn for player '+turn+' move which space')
    move=input()
    if theBoard[move]==' ':
        theBoard[move]=turn
        numberOfMove =numberOfMove+1
        if turn=='x':
            turn='o'
        else:
            turn='x'
    else:
        print('space is already fille.\n move to which space')
        print('m_ove:'+str(i))
        continue
       
printBoard(theBoard)
print(numberOfMove)
```

     | | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    7
    x| | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player o move which space
    8
    x|o| 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    3
    x|o| 
    -+-+-
     | | 
    -+-+-
     | |x
    turn for player o move which space
    9
    x|o|o
    -+-+-
     | | 
    -+-+-
     | |x
    turn for player x move which space
    5
    x|o|o
    -+-+-
     |x| 
    -+-+-
     | |x
    turn for player o move which space
    6
    x|o|o
    -+-+-
     |x|o
    -+-+-
     | |x
    turn for player x move which space
    4
    x|o|o
    -+-+-
    x|x|o
    -+-+-
     | |x
    turn for player o move which space
    1
    x|o|o
    -+-+-
    x|x|o
    -+-+-
    o| |x
    turn for player x move which space
    2
    x|o|o
    -+-+-
    x|x|o
    -+-+-
    o|x|x
    9
    

####  Complete  tic-tac-toe game


```python
theBoard={'7':' ','8':' ','9':' ',
          '4':' ','5':' ','6':' ',
          '1':' ','2':' ','3':' '}

def printBoard(board):
    print(board['7']+'|'+board['8']+'|'+board['9'])
    print('-+-+-')
    print(board['4']+'|'+board['5']+'|'+board['6'])
    print('-+-+-')
    print(board['1']+'|'+board['2']+'|'+board['3'])
    
    
   
def game():    
    turn='x'
    count=0
    for i in range(20):
        printBoard(theBoard)
        print('turn for player '+turn+' move which space')

        move=input()

        if theBoard[move]==' ':
            theBoard[move]=turn
            count+=1
        else:
            print('space is already fille.\n move to which space')
            continue

        if count>=5:
            if theBoard['7']==theBoard['8']==theBoard['9']!=' ':
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
            elif theBoard['4']==theBoard['5']==theBoard['6']!=' ':
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
            elif theBoard['1']==theBoard['2']==theBoard['3']!=' ':
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
            elif theBoard['7']==theBoard['4']==theBoard['1']!=' ':
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
            elif theBoard['8']==theBoard['5']==theBoard['2']!=' ':
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
            elif theBoard['9']==theBoard['6']==theBoard['3']!=' ':
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
            elif theBoard['7']==theBoard['5']==theBoard['3']!=' ':
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
            elif theBoard['9']==theBoard['5']==theBoard['1']:
                printBoard(theBoard)
                print('player '+turn+ ' won\nGAME OVER')
                break
                
                
        if count==9:
            print('match DRAW\n GAME OVER')


        if turn=='x':                     #chenging turn of player 
                turn='o'
        else:
                turn='x'
                
game()
printBoard(theBoard)
```

     | | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    7
    x| | 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player o move which space
    8
    x|o| 
    -+-+-
     | | 
    -+-+-
     | | 
    turn for player x move which space
    5
    x|o| 
    -+-+-
     |x| 
    -+-+-
     | | 
    turn for player o move which space
    9
    x|o|o
    -+-+-
     |x| 
    -+-+-
     | | 
    turn for player x move which space
    3
    x|o|o
    -+-+-
     |x| 
    -+-+-
     | |x
    player x won
    GAME OVER
    x|o|o
    -+-+-
     |x| 
    -+-+-
     | |x
    

### Nested Dictionaries and Lists
 Lists are useful to contain an ordered series of values, and dictionaries are useful for associating keys with values. For
example, here’s a program that uses a dictionary that contains other dictionaries in order to see who is bringing what to a picnic. The totalBrought() function can read this data structure and calculate the total number of an item being brought by all the guests.



```python
allGuest={'alice':{'apple':5,'pine':120},
          'bob':{'apple':5,'mango':7, 'banana':12},
          'carol':{'banana':8,'papaya':1}}
def totalBrought(guest,items):
    numbBrought=0
    for k,v in guest.items():                           # the for loop iterates over the keyvalue pairs in guests 
        numbBrought=numbBrought+v.get(items,0)
    return(numbBrought)
print('no of things being brought')
print('apples '+str(totalBrought(allGuest,'apple')))
print('apples '+str(totalBrought(allGuest,'pine')))
print('apples '+str(totalBrought(allGuest,'mango')))
print('apples '+str(totalBrought(allGuest,'banana')))
print('apples '+str(totalBrought(allGuest,'anaar')))
```

    no of things being brought
    apples 10
    apples 120
    apples 7
    apples 20
    apples 0
    

 Inside the loop, the string of the guest’s name is assigned to **k**, and the dictionary of picnic items they’re bringing is assigned to **v**. If the item parameter exists as a key in this dictionary, it’s value (the quantity) is added to **numBrough**. If it does not exist as a key, the get()
method returns 0 to be added to numBrought.

## Summary
You learned all about dictionaries in this chapter. Lists and dictionaries are values that can contain multiple values, including other lists and dictionaries. Dictionaries are useful because you can map one item (the key) to another (the value), as opposed to lists, which simply contain a series of values in order. Values inside a dictionary are accessed using square brackets just as with lists. Instead of an integer index, dictionaries can have keys of a variety of data types: integers, floats, strings, or tuples. By organizing a program’s values into data structures, you can create representations of real-world objects. You saw an example of this with a tic-tac-toe board.

That just about covers all the basic concepts of Python programming! You’ll continue to learn new concepts throughout the rest of this book, but you now know enough to start writing some useful programs that can automate tasks. You might not think you have enough Python knowledge to do things such as download web pages, update spreadsheets, or send text messages, but that’s where Python modules come in! These modules, written by other programmers, provide functions that make it easy for you to do all these things. So let’s learn how to write real programs to do useful automated tasks.

## Practice Projects
### Fantasy Game Inventory

You are creating a fantasy video game. The data structure to model the player’s inventory will be a dictionary where the keys are string values describing the item in the inventory and the value is an integer value detailing how many of that item the player has. For example, the dictionary value

    {'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12}

means the player has 1 rope, 6 torches, 42 gold coins, and so on. Write a function named displayInventory() that would take any possible
“inventory” and display it like the following:

    Inventory:
    12 arrow
    42 gold coin
    1 rope
    6 torch
    1 dagger
    Total number of items: 62
    
Hint: You can use a for loop to loop through all the keys in a dictionary.

    # inventory.py
    stuff = {'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12}
    def displayInventory(inventory):
     print("Inventory:")
     item_total = 0
     for k, v in inventory.items():
     print(str(v) + ' ' + k)
     item_total += v
     print("Total number of items: " + str(item_total))
    displayInventory(stuff)


```python
stuff={'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12}

def displayInventory(inventory):
    total=0
    for k, v in inventory.items():
        print(str(v) +'    '+    k)
        total=total+v
    print('Total number of items:' +str(total))
displayInventory(stuff)
```

    1    rope
    6    torch
    42    gold coin
    1    dagger
    12    arrow
    Total number of items:62
    

### List to Dictionary Function for Fantasy Game Inventory

Imagine that a vanquished dragon’s loot is represented as a list of strings like this:

     dragonLoot = ['gold coin', 'dagger', 'gold coin', 'gold coin', 'ruby']
        
Write a function named addToInventory(inventory, addedItems), where the inventory parameter is a dictionary representing the player’s inventory (like in the previous project) and the addedItems parameter is a list like dragonLoot. 


```python
dragonLoot = ['gold coin', 'dagger', 'gold coin', 'gold coin', 'ruby','rope','dagger']
inv = {'gold coin': 42, 'rope': 1}

def addToInventory(inventory,addedItems):
    for i in addedItems:
        if i in inventory:
            inventory[i]=inventory.get(i,0)+1    
        else:
            inventory[i]=1
            

def displayInventory(inventory):
    total=0
    for k, v in inventory.items():
        print(str(v) +'    '+    k)
        total=total+v
    print('Total number of items:' +str(total))
    
    
addToInventory(inv,dragonLoot)    
displayInventory(inv)   
```

    45    gold coin
    2    rope
    2    dagger
    1    ruby
    Total number of items:50
    

# Arrays
An array is a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together. This makes it easier to calculate the position of each element by simply adding an offset to a base value, i.e., the memory location of the first element of the array (generally denoted by the name of the array).

or simplicity, we can think of an array a fleet of stairs where on each step is placed a value (let’s say one of your friends). Here, you can identify the location of any of your friends by simply knowing the count of the step they are on. Array can be handled in Python by a module named array. They can be useful when we have to manipulate only a specific data type values. A user can treat lists as arrays. However, user cannot constraint the type of elements stored in a list. If you create arrays using the array module, all elements of the array must be of the same type.
![title](https://media.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign1-min.png)

Array in Python can be created by importing array module. array(data_type, value_list) is used to create an array with data type and value list specified in its arguments.


```python
# Python program to demonstrate
# Creation of Array

# importing "array" for array creations
import array as arr

# creating an array with integer type
a = arr.array('i', [1, 2, 3])

# printing original array
print("The new created array is : ", end=" ")
for i in range(0, 3):
    print(a[i], end=" ")
print()

# creating an array with float type
b = arr.array('d', [2.5, 3.2, 3.3])

# printing original array
print("The new created array is : ", end=" ")
for i in range(0, 3):
    print(b[i], end=" ")
```

    The new created array is :  1 2 3 
    The new created array is :  2.5 3.2 3.3 

## creating an array of different data types

**Some of the data types are mentioned below which will help in creating an array of different data types**
![title](https://media.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign2-min.png)

## Adding elements in array
Elements can be added to the Array by using built-in **insert()** function. Insert is used to insert one or more data elements into an array. Based on the requirement, a new element can be added at the beginning, end, or any given index of **array. append()** is also used to add the value mentioned in its arguments at the end of the array.


```python
# Python program to demonstrate
# Adding Elements to a Array

# importing "array" for array creations
import array as arr

# array with int type
a = arr.array('i', [1, 2, 3])

print("Array before insertion : ", end=" ")
for i in range(0, 3):
    print(a[i], end=" ")
print()

# inserting array using
# insert() function
a.insert(1, 4)

print("Array after insertion : ", end=" ")
for i in (a):
    print(i, end=" ")
print()

# array with float type
b = arr.array('d', [2.5, 3.2, 3.3])

print("Array before insertion : ", end=" ")
for i in range(0, 3):
    print(b[i], end=" ")
print()

# adding an element using append()
b.append(4.4)

print("Array after insertion : ", end=" ")
for i in (b):
    print(i, end=" ")
print()
```

    Array before insertion :  1 2 3 
    Array after insertion :  1 4 2 3 
    Array before insertion :  2.5 3.2 3.3 
    Array after insertion :  2.5 3.2 3.3 4.4 
    

## Removing Elements from array
elements can be removed from the array by using built-in **remove()** function but an **Error arises if element doesn’t exist in the set**. **Remove() method only removes one element at a time,** to **remove range of elements, iterator is used.pop()** function can also be used to **remove and return an element from the array**, but by default it removes only the last element of the array, to remove element from a specific position of the array, index of the element is passed as an argument to the pop() method.

**Note– Remove method in List will only remove the first occurrence of the searched element.**


```python
# Python program to demonstrate
# Removal of elements in a Array

# importing "array" for array operations
import array

# initializing array with array values
# initializes array with signed integers
arr = array.array('i', [1, 2, 3, 1, 5])

# printing original array
print("The new created array is : ", end="")
for i in range(0, 5):
    print(arr[i], end=" ")

print("\r")

# using pop() to remove element at 2nd position
print("The popped element is : ", end="")
print(arr.pop(2))

# printing array after popping
print("The array after popping is : ", end="")
for i in range(0, 4):
    print(arr[i], end=" ")

print("\r")

# using remove() to remove 1st occurrence of 1
arr.remove(1)

# printing array after removing
print("The array after removing is : ", end="")
for i in range(0, 3):
    print(arr[i], end=" ")
```

    The new created array is : 1 2 3 1 5 
    The popped element is : 3
    The array after popping is : 1 2 1 5 
    The array after removing is : 2 1 5 

## Slicing of a Array
we use Slice operation. Slice operation is performed on array with the use of colon(:). To print elements from beginning to a range use [:Index], to print elements from end use [:-Index], to print elements from specific Index till the end use [Index:], to print elements within a range, use [Start Index:End Index] and to print whole List with the use of slicing operation, use [:]. Further, to print whole array in reverse order, use [::-1].

![title](https://media.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign3-min.png)


```python
# Python program to demonstrate
# silicing of elements in a Array

# importing array module
import array as arr

# creating a list
l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

a = arr.array('i', l)
print("Intial Array: ")
for i in (a):
    print(i, end=" ")

# Print elements of a range
# using Slice operation
Sliced_array = a[3:8]
print("\nSlicing elements in a range 3-8: ")
print(Sliced_array)

# Print elements from a
# pre-defined point to end
Sliced_array = a[5:]
print("\nElements sliced from 5th " "element till the end: ")
print(Sliced_array)

# Printing elements from
# beginning till end
Sliced_array = a[:]
print("\nPrinting all elements using slice operation: ")
print(Sliced_array)
```

    Intial Array: 
    1 2 3 4 5 6 7 8 9 10 
    Slicing elements in a range 3-8: 
    array('i', [4, 5, 6, 7, 8])
    
    Elements sliced from 5th element till the end: 
    array('i', [6, 7, 8, 9, 10])
    
    Printing all elements using slice operation: 
    array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    

## Searching element in a Array
In order to search an element in the array we use a python in-built **index()** method. This function returns the index of the first occurrence of value mentioned in arguments.



```python
# Python code to demonstrate
# searching an element in array

# importing array module
import array

# initializing array with array values
# initializes array with signed integers
arr = array.array('i', [1, 2, 3, 1, 2, 5])

# printing original array
print("The new created array is : ", end="")
for i in range(0, 6):
    print(arr[i], end=" ")

print("\r")

# using index() to print index of 1st occurrenece of 2
print("The index of 1st occurrence of 2 is : ", end="")
print(arr.index(2))

# using index() to print index of 1st occurrenece of 1
print("The index of 1st occurrence of 1 is : ", end="")
print(arr.index(1))
```

    The new created array is : 1 2 3 1 2 5 
    The index of 1st occurrence of 2 is : 1
    The index of 1st occurrence of 1 is : 0
    

## Updating Elements in a Array
In order to update an element in the array we simply reassign a new value to the desired index we want to update.


```python
# Python code to demonstrate
# how to update an element in array

# importing array module
import array

# initializing array with array values
# initializes array with signed integers
arr = array.array('i', [1, 2, 3, 1, 2, 5])

# printing original array
print("Array before updation : ", end="")
for i in range(0, 6):
    print(arr[i], end=" ")

print("\r")

# updating a element in a array
arr[2] = 6
print("Array after updation : ", end="")
for i in range(0, 6):
    print(arr[i], end=" ")
print()

# updating a element in a array
arr[4] = 8
print("Array after updation : ", end="")
for i in range(0, 6):
    print(arr[i], end=" ")
```

    Array before updation : 1 2 3 1 2 5 
    Array after updation : 1 2 6 1 2 5 
    Array after updation : 1 2 6 1 8 5 


```python

```


```python

```

# Manipulating Strings
strings from string values, add or remove spacing, convert letters to lowercase or uppercase, and check that strings are formatted correctly. You can even write Python code to access the clipboard for copying and pasting text. In this chapter, you’ll learn all this and more. Then you’ll work through two different programming projects: a simple password manager and a program to automate the boring chore of formatting pieces of text.

1. A string is a sequence of characters.
2. Computers do not deal with characters, they deal with numbers (binary). Even though you may see characters on your screen, internally it is stored and manipulated as a combination of 0's and 1's.
3. This conversion of character to a number is called encoding, and the reverse process is decoding. ASCII and Unicode are some of the popular encoding used.
4. In Python, string is a sequence of Unicode character.


## Working with Strings

### String Literals
   Strings can begin and end with double quotes, just as they do with single quotes. One benefit of using double quotes is that the string can have a single quote character in it. Enter the following into the interactive shell:

        spam = "That is Alice's cat."

Since the string begins with a double quote, Python knows that the single quote is part of the string and not marking the end of the string. However, if you need to use both single quotes and double quotes in the string, you’ll need to use escape characters.

### Escape Characters

An **escape character** lets you use characters that are otherwise impossible to put into a string. An escape character consists of a backslash (\) followed by the character you want to add to the string. (Despite consisting of two characters, it is commonly referred to as a singular escape character.) For example, the escape character for a single quote is \'. You can use this
inside a string that begins and ends with single quotes. To see how escape characters work, enter the following into the interactive shell:

    spam = 'Say hi to Bob\'s mother.'
    
Python knows that since the single quote in Bob\'s has a backslash, it is not a single quote meant to end the string value. The escape characters \' and \" let you put single quotes and double quotes inside your strings, respectively.

     **Escape Characters**
     
    Escape       character Prints as
    \'            Single quote
    \"            Double quote
    \t            Tab
    \n            Newline (line break)
    \\            Backslash

**Strings can be created by enclosing characters inside a *single quote* or *double quotes*.
Even *triple quotes* can be used in Python but generally used to represent multiline strings and docstrings.**


```python
myString = 'Hello'
print(myString)

myString = "Hello"
print(myString)

myString = '''Hello'''
print(myString)
```

    Hello
    Hello
    Hello
    


```python
print("Hello there!\nHow are you?\nI'm doing fine.")
```

    Hello there!
    How are you?
    I'm doing fine.
    


```python
print('Hello there!\nHow are you?\I\'m doing fine.')
```

    Hello there!
    How are you?\I'm doing fine.
    


```python
print("Say hi to Bob's mother.")
```

    Say hi to Bob's mother.
    


```python
print('Say hi to Bob's mother.')
```


      File "<ipython-input-260-13ed596c9d7e>", line 1
        print('Say hi to Bob's mother.')
                             ^
    SyntaxError: invalid syntax
    



```python
print('Say hi to Bob\'s mother.')
```

    Say hi to Bob's mother.
    

### Raw Strings
You can place an r before the beginning quotation mark of a string to make it a raw string. A raw string completely ignores all escape characters and prints any backslash that appears in the string. 


```python
print(r'Hello there!\nHow are you?\I\'m doing fine.')
```

    Hello there!\nHow are you?\I\'m doing fine.
    

### Multiline Strings with Triple Quotes

While you can use the \n escape character to put a newline into a string, it is often easier to use multiline strings. A multiline string in Python begins and ends with either three single quotes or three double quotes. Any quotes, tabs, or newlines in between the “triple quotes” are considered part of the string. Python’s indentation rules for blocks do not apply to lines inside a multiline string.



```python
print('''Dear Alice,
    Eve's cat has been arrested for catnapping, cat burglary, and extortion.
    Sincerely,
    Bob''')
```

    Dear Alice,
        Eve's cat has been arrested for catnapping, cat burglary, and extortion.
        Sincerely,
        Bob
    


```python
print('''Dear Alice,

Eve's cat has been arrested for catnapping, cat burglary, and extortion.

Sincerely,
Bob''')
```

    Dear Alice,
    
    Eve's cat has been arrested for catnapping, cat burglary, and extortion.
    
    Sincerely,
    Bob
    

Notice that the single quote character in Eve's does not need to be escaped. Escaping single and double quotes is optional in raw strings. The following print() call would print identical text but doesn’t use a multiline string:


```python
print('Dear Alice,\n\nEve\'s cat has been arrested for catnapping, cat burglary, and extortion.\n\nSincerely,\nBob')
```

    Dear Alice,
    
    Eve's cat has been arrested for catnapping, cat burglary, and extortion.
    
    Sincerely,
    Bob
    

### Multiline Comments
While the hash character (#) marks the beginning of a comment for the rest of the line, a multiline string is often used for comments that span multiple lines.


```python
"""This is a test Python program.
Written by Al Sweigart al@inventwithpython.com
This program was designed for Python 3, not Python 2.
"""
def spam():
 """This is a multiline comment to help
 explain what the spam() function does."""
 print('Hello!')
spam()
```

    Hello!
    

### Indexing and Slicing Strings

Strings use indexes and slices the same way lists do. You can think of the
string 'Hello world!' as a list and each character in the string as an item
with a corresponding index.

    '   H  e  l  l  o    w  o  r  l   d   ! '
        0  1  2  3  4  5 6  7  8  9  10  11

The space and exclamation point are included in the character count,
so 'Hello world!' is 12 characters long, from H at index 0 to ! at index 11.
Enter the following into the interactive shell:



```python
spam = 'Hello world!'
spam[0]
```




    'H'




```python
spam[11]
```




    '!'




```python
spam[0:4]
```




    'Hell'




```python
spam[-3]
```




    'l'




```python
spam[:5]
```




    'Hello'




```python
spam[6:]
```




    'world!'




```python
spam='hello world'
fizz=spam[:6]
fizz
```




    'hello '




```python
fizz[3]
```




    'l'




```python
myString = "Hello"

#print first Character
print(myString[0])

#print last character using negative indexing
print(myString[-1])

#slicing 2nd to 5th character
print(myString[2:5])
```

    H
    o
    llo
    


```python
print(myString[15])
```


    ---------------------------------------------------------------------------

    IndexError                                Traceback (most recent call last)

    <ipython-input-276-a6e04654a783> in <module>
    ----> 1 print(myString[15])
    

    IndexError: string index out of range



```python
print(myString[1.5])
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-277-f317be76d762> in <module>
    ----> 1 print(myString[1.5])
    

    TypeError: string indices must be integers


### How to change or delete a string ?
Strings are **immutable**. This means that elements of a string **cannot be changed once it has been assigned.** **We can simply reassign different strings to the same name.**


```python
myString = "Hello"
myString[4] = 's' # strings are immutable
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-278-786fea0a1f9c> in <module>
          1 myString = "Hello"
    ----> 2 myString[4] = 's' # strings are immutable
    

    TypeError: 'str' object does not support item assignment


**We cannot delete or remove characters from a string. But deleting the string entirely is possible using the keyword del.**


```python
del myString # delete complete string
```


```python
print(myString)
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-280-13235c81a0c6> in <module>
    ----> 1 print(myString)
    

    NameError: name 'myString' is not defined


### Concatenation
1. Joining of two or more strings into a single one is called concatenation.
2. The + operator does this in Python. Simply writing two string literals together also concatenates them.
3. The * operator can be used to repeat the string for a given number of times.


```python
s1 = "Hello "
s2 = "Satish"

                           #concatenation of 2 strings
print(s1 + s2)

                             #repeat string n times
print(s1 * 3)
```

    Hello Satish
    Hello Hello Hello 
    

### Iterating Through String


```python
count = 0
for l in "Hello World":
    if l == 'o':
        count += 1
print(count, ' letters found')
```

    2  letters found
    

### The in and not in Operators with Strings

The in and not in operators can be used with strings just like with list values. An expression with two strings joined using in or not in will evaluate to a Boolean True or False.


```python
'Hello' in 'Hello World'
```




    True




```python
'HELLO' in 'Hello World'
```




    False




```python
'' in 'world'
```




    True




```python
'cats' not in 'cats and dogs'
```




    False



These expressions test whether the first string (the exact string, case sensitive) can be found within the second string.

## Useful String Methods
### The upper(), lower(), isupper(), and islower() String Methods

The upper() and lower() string methods return a new string where all the letters in the original string have been converted to uppercase or lowercase, respectively. Nonletter characters in the string remain unchanged. 



```python
spam='Hello World!'
spam= spam.upper()
spam
```




    'HELLO WORLD!'




```python
spam='Hello World!'
spam= spam.lower()
spam
```




    'hello world!'



Note that these methods do not change the string itself but return new string values.  This is why you must use **spam =
spam.upper()** to change the string in spam instead of simply spam.upper(). *(This is just like if a variable eggs contains the value 10. Writing eggs + 3 does not change the value of eggs, but eggs = eggs + 3 does.)*



```python
print('How are you?')
feeling = input()
if feeling.lower() == 'great':
 print('I feel great too.')
else:
 print('I hope the rest of your day is good.')
```

    How are you?
    bad
    I hope the rest of your day is good.
    

The **upper()** and **lower()** methods are helpful if you need to make a **case-insensitive comparison.** The strings 'great' and 'GREat' are not equal to each other. But in the following small program, it does not matter whether the user types Great, GREAT, or grEAT, because the string is first converted to
lowercase.

The **isupper() and islower()** methods will return a **Boolean** True value if the string has at least one letter and all the letters are uppercase or lowercase, respectively. Otherwise, the method returns False. Enter the following into the interactive shell, and notice what each method call returns:


```python
spam='Hello World!'
spam.islower()
```




    False




```python
spam='hello world!'
spam.islower()
```




    True




```python
'hello'.islower()
```




    True




```python
'abd543'.islower()
```




    True




```python
'ABS123'.isupper()
```




    True




```python
'1234'.islower()
```




    False




```python
'12345'.isupper()
```




    False



Since the **upper()** and **lower()** string methods themselves return strings, you can call string methods on those returned string values as well. Expressions that do this will look like a **chain of method** calls. 


```python
'HELLO'.lower()
```




    'hello'




```python
'hello'.upper().isupper()
```




    True




```python
'Hello'.lower().islower()
```




    True



### find(), replace() methods



```python
spam='''These methods are useful alternatives to the == equals operator 
if you need to check only whether the first or last part of the string,
rather than the whole thing, is equal to another string.'''

spam.find('e')
```




    2




```python
"Good Morning".find("Mo")
```




    5




```python
s1 = "Bad morning"

s2 = s1.replace("Bad", "Good")

print(s1)
print(s2)
```

    Bad morning
    Good morning
    

#### Python Program to Check where a String is Palindrome or not ?



```python
#without using reversed(Str) funstion

spam=input('enter a word:')
spam=spam.lower()
s=''
for i in range (len(spam)-1,-1,-1):
    print(spam[i])
    s=s+spam[i]
print(s)

if s==spam:
    print(spam+':is a palindrome')
else:
    print(spam+':is not palindrom')  #e.g. saippuakivikauppias is a palindrom
```

    enter a word:maDaM
    m
    a
    d
    a
    m
    madam
    madam:is a palindrome
    


```python
myStr = "Madam"

#convert entire string to either lower or upper
myStr = myStr.lower()

#reverse string
revStr = reversed(myStr)


#check if the string is equal to its reverse
if list(myStr) == list(revStr):
    print("Given String is palindrome")
else:
    print("Given String is not palindrome")

```

    Given String is palindrome
    

#### Python Program to Sort Words in Alphabetic Order?


```python
myStr = "python Program to Sort words in Alphabetic Order"

#breakdown the string into list of words
words = myStr.split()

#sort the list
words.sort()

#print Sorted words are
for word in words:
    print(word)
```

    Alphabetic
    Order
    Program
    Sort
    in
    python
    to
    words
    

### The isX String Methods
Along with islower() and isupper(), there are several string methods that have names beginning with the word is. **These methods return a Boolean value** that describes the nature of the string.

    •	 isalpha() returns True if the string consists only of letters and is not blank.
    •	 isalnum() returns True if the string consists only of letters and numbers and is not blank.
    •	 isdecimal() returns True if the string consists only of numeric characters and is not blank.
    •	 isspace() returns True if the string consists only of spaces, tabs, and newlines and is not blank.
    •	 istitle() returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters.


```python
'Hello'.isalpha()
```




    True




```python
'Hello123'.isalpha()
```




    False




```python
'Hello123/'.isalnum()
```




    False




```python
'123'.isalnum()
```




    True




```python
'Hello'.isalnum()
```




    True




```python
'123'.isdecimal()
```




    True




```python
'123Hellow'.isdecimal()
```




    False




```python
'   '.isspace()
```




    True




```python
'\n  '.isspace()
```




    True




```python
' n '.isspace()
```




    False




```python
'This Is A Tiyle'.istitle()
```




    True




```python
'This is Not The Title'.istitle()
```




    False




```python
'This IS A Not Title.istitle()'.istitle()
```




    False




```python
'This Is The Title 123'.istitle()
```




    True



The **isX** string methods are helpful when you need to validate user input. For example, the following program repeatedly asks users for their age and a password until they provide valid input


```python
while True:
    age=input('enter your age:')
    if age.isdecimal():
        break
    else:
        print('Enter your age in decimal')
while True:
    pswrd=input('enter your password:')
    if pswrd.isalnum():
        break
    else:
        print('password can be only alpha or numeric')
        
```

    enter your age:25.0
    Enter your age in decimal
    enter your age:25
    enter your password:pky256
    

**These methods are useful alternatives to the == equals operator if you need to check only whether the first or last part of the string, rather than the whole thing, is equal to another string.**

### The *join()* and *split()* String Methods
The join() method is useful when you have a list of strings that need to be joined together into a single string value. The join() method is called on a string, gets passed a list of strings, and returns a string. The returned string
is the concatenation of each string in the passed-in list. For example, enter the following into the interactive shell:



```python
','.join(['cat','dog','cow'])
```




    'cat,dog,cow'




```python
''.join(['cat','dog','cow'])
```




    'catdogcow'




```python
' '.join(['cat','dog','cow'])
```




    'cat dog cow'




```python
' $ '.join(['cat','dog','cow'])
```




    'cat $ dog $ cow'




```python
'ABC'.join(['cat','dog','cow'])
```




    'catABCdogABCcow'



Remember that **join() is called on a string value and is passed a list value.** (It’s easy to accidentally call it the other way around.) **The split() method does the opposite: It’s called on a string value and returns a list of strings.**


```python
'I am pramod kumar yadav'.split()
```




    ['I', 'am', 'pramod', 'kumar', 'yadav']




```python
'iABCamABCpramodABCkuamr'.split('ABC')
```




    ['i', 'am', 'pramod', 'kuamr']




```python
'I am pramod kumar yadav'.split('a')
```




    ['I ', 'm pr', 'mod kum', 'r y', 'd', 'v']




```python
#let's take a string

s = "one,two,three,four,five"
slst = s.split(',')
print(slst)
```

    ['one', 'two', 'three', 'four', 'five']
    

***A common use of split() is to split a multiline string along the newline characters. Enter the following into the interactive shell:***


```python
spam = '''Dear Alice,
How have you been? I am fine.
There is a container in the fridge
that is labeled "Milk Experiment".
Please do not drink it.
Sincerely,
Bob'''
spam
```




    'Dear Alice,\nHow have you been? I am fine.\nThere is a container in the fridge\nthat is labeled "Milk Experiment".\nPlease do not drink it.\nSincerely,\nBob'




```python
spam = '''Dear Alice,
How have you been? I am fine.
There is a container in the fridge
that is labeled "Milk Experiment".
Please do not drink it.
Sincerely,
Bob'''
print(spam)
```

    Dear Alice,
    How have you been? I am fine.
    There is a container in the fridge
    that is labeled "Milk Experiment".
    Please do not drink it.
    Sincerely,
    Bob
    


```python
spam = '''Dear Alice,
How have you been? I am fine.
There is a container in the fridge
that is labeled "Milk Experiment".
Please do not drink it.
Sincerely,
Bob'''


spam.split('\n')
```




    ['Dear Alice,',
     'How have you been? I am fine.',
     'There is a container in the fridge',
     'that is labeled "Milk Experiment".',
     'Please do not drink it.',
     'Sincerely,',
     'Bob']



Passing split() the argument '\n' lets us split the multiline string stored in spam along the newlines and return a list in which each item corresponds to one line of the string.

### Justifying Text with *rjust()*, *ljust()*, and *center()*

   The *rjust()* and *ljust()* string methods return a padded version of the string they are called on, with **spaces inserted to justify the text**. The **first argument to both methods is an integer** length for the justified string. 


```python
'hello'.rjust(10)
```




    '     hello'




```python
'hello'.ljust(10)
```




    'hello     '




```python
'hello'.center(10)
```




    '  hello   '




```python
'hello world'.rjust(20)
```




    '         hello world'



**'Hello'.rjust(10)** says that we want to **right-justify 'Hello'** in a string of **total length 10.** **'Hello' is five** characters, **so five spaces will be added to its left**, giving us a string of 10 characters with 'Hello' justified right.


```python
'Hello'.rjust(10,'*')
```




    '*****Hello'




```python
'Hello'.center(15,'=')
```




    '=====Hello====='



**These methods are especially useful when you need to print tabular data that has the correct spacing. Open a new file editor window and enter the following code,**


```python
def itemPrint(itemDict,leftWidth,rightWidth):
    print('ITEMS LIST'.center(leftWidth+rightWidth,'.'))
    for k,v in itemDict.items():
        print(k.ljust(leftWidth,'.')+str(v).rjust(rightWidth))
        
picnicItems={'apple':20, 'banana':24,'boll':2, 'tennice':'two'}

itemPrint(picnicItems,10,5)
itemPrint(picnicItems,20,10)
```

    ...ITEMS LIST..
    apple.....   20
    banana....   24
    boll......    2
    tennice...  two
    ..........ITEMS LIST..........
    apple...............        20
    banana..............        24
    boll................         2
    tennice.............       two
    

### Removing Whitespace with *strip()*, *rstrip()*, and *lstrip()*

Sometimes you may want to strip off whitespace characters (space, tab, and newline) from the left side, right side, or both sides of a string. The strip() string method will return a new string without any whitespace characters at the beginning or end. The lstrip() and rstrip() methods will remove whitespace characters from the left and right ends, respectively. Enter the following into the interactive shell:


```python
spam='  hello   '
spam.strip()
```




    'hello'




```python
spam='  hello   '
spam.rstrip()
```




    '  hello'




```python
spam='  hello   '
spam.lstrip()
```




    'hello   '




```python
spam='     hello  world    '
spam.strip()
```




    'hello  world'



**Optionally, a string argument will specify which characters on the ends should be stripped. Enter the following into the interactive shell:**


```python
spam = 'SpamSpamBaconSpamEggsSpamSpam'
spam.strip('Samp')
```




    'BaconSpamEggs'



Passing strip() the argument 'ampS' will tell it to strip occurences of a, m, p, and capital S from the ends of the string stored in spam. **The order of the characters in the string passed to strip() does not matter**: **strip('ampS') will do the same thing as strip('mapS') or strip('Spam').**

### Copying and Pasting Strings with the pyperclip Module
The pyperclip module has copy() and paste() functions that can send text to and receive text from your computer’s clipboard. Sending the output of your program to the clipboard will make it easy to paste it to an email, word processor, or some other software. Pyperclip does not come with Python. To install it, follow the directionsfor installing third-party modules...
Of course, if something outside of your program changes the clipboardcontents, the paste() function will return it.


```python
 import pyperclip
pyperclip.copy('Hello world!')
pyperclip.paste()
```




    'Hello world!'




```python
import pyperclip
pyperclip.copy('Hello world!')
pyperclip.paste()
```




    'Hello world!'



## Project: Password Locker

The password manager program you’ll create in this example isn’t secure, but it offers a basic demonstration of how such programs work.
### Step 1: Program Design and Data Structures
(*pyperclip module not imported so we cant do this currently)

## Project: Adding Bullets to Wiki Markup


```python
text='''We split the text along its newlines to get a list in which each item is one
line of the text. We store the list in lines and then loop through the items in
lines. For each line, we add a star and a space to the start of the line. Now
each string in lines begins with a star'''
lines = text.split('\n')
lines
```




    ['We split the text along its newlines to get a list in which each item is one',
     'line of the text. We store the list in lines and then loop through the items in',
     'lines. For each line, we add a star and a space to the start of the line. Now',
     'each string in lines begins with a star']




```python
text='''We split the text along its newlines to get a list in which each item is one
line of the text. We store the list in lines and then loop through the items in
lines. For each line, we add a star and a space to the start of the line. Now
each string in lines begins with a star'''
lines = text.split('\n')
for i in range (len(lines)):
    lines[i]='*'+lines[i]
    print (lines[i])
```

    *We split the text along its newlines to get a list in which each item is one
    *line of the text. We store the list in lines and then loop through the items in
    *lines. For each line, we add a star and a space to the start of the line. Now
    *each string in lines begins with a star
    


```python
text=pyperclip.paste()
lines = text.split('\n')
for i in range (len(lines)):
    lines[i]='*'+lines[i]
    print (lines[i])
```

    *Hello world!
    

## Summary
Text is a common form of data, and Python comes with many helpful string methods to process the text stored in string values. You will make use of indexing, slicing, and string methods in almost every Python program you
write. The programs you are writing now don’t seem too sophisticated—they don’t have graphical user interfaces with images and colorful text. So far, you’re displaying text with print() and letting the user enter text with input(). However, the user can quickly enter large amounts of text through the clipboard. This ability provides a useful avenue for writing programs that manipulate massive amounts of text. These text-based programs might not have flashy windows or graphics, but they can get a lot of useful work done quickly. Another way to manipulate large amounts of text is reading and writing files directly off the hard drive. You’ll learn how to do this with Python in the next chapter.

## Practice Project
### Table Printer
Write a function named printTable() that takes a list of lists of strings and displays it in a well-organized table with each column right-justified. Assume that all the inner lists will contain the same number of strings. For example, the value could look like this:

    tableData = [['apples', 'oranges', 'cherries', 'banana'],
                ['Alice', 'Bob', 'Carol', 'David'],
                ['dogs', 'cats', 'moose', 'goose']]
                
Your printTable() function would print the following:

     apples Alice dogs
     oranges Bob cats
     cherries Carol moose
     banana David goose                


```python
tableData = [['apples', 'oranges', 'cherries', 'banana'],
            ['Alice', 'Bob', 'Carol', 'David'],
            ['dogs', 'cats', 'moose', 'goose']]
for i in range (len(tableData)):
    print(' '.join(tableData[i]))
    
```

    apples oranges cherries banana
    Alice Bob Carol David
    dogs cats moose goose
    


```python
tableData = [['apples', 'oranges', 'cherries', 'banana'],
            ['Alice', 'Bob', 'Carol', 'David'],
            ['dogs', 'cats', 'moose', 'goose']]
def printTable(tableData):
    for i in range(len(tableData)):
        for j in range(len(tableData[i])):
            for i in range(len(tableData)):
                print(tableData[i][j],end=' ')     
            print('') 
        break
printTable(tableData)    
  
```

    apples Alice dogs 
    oranges Bob cats 
    cherries Carol moose 
    banana David goose 
    


```python
tableData = [['apples', 'oranges', 'cherries', 'banana'],
            ['Alice', 'Bob', 'Carol', 'David'],
            ['dogs', 'cats', 'moose', 'goose']]

def printTable(tableData):  
    for j in range(len(tableData[1])):
        for i in range(len(tableData)):
            print(tableData[i][j],end=' ')     
        print('') 
        
printTable(tableData) 
```

    apples Alice dogs 
    oranges Bob cats 
    cherries Carol moose 
    banana David goose 
    

# Classes and Objects
1. user-defined blueprint or prototype from which objects are created. Classes provide a means of bundling data and functionality together.
2. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. 
3. Class creates a user-defined data structure, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class. A class is like a blueprint for an object.

To understand the need for creating a class let’s consider an example, let’s say you wanted to track the number of dogs which may have different attributes like breed, age. If a list is used, the first element could be the dog’s breed while the second element could represent its age. Let’s suppose there are 100 different dogs, then how would you know which element is supposed to be which? What if you wanted to add other properties to these dogs? This lacks organization and it’s the exact need for classes.

## Some points on Python class:

Classes are created by keyword class.
Attributes are the variables that belong to class.
Attributes are always public and can be accessed using dot (.) operator. Eg.: Myclass.Myattribute

    Class Definition Syntax:

    class ClassName:
        # Statement-1
        .
        .
        .
        # Statement-N

## Defining a class


```python
# Python program to
# demonstrate defining
# a class


class Dog:
    pass
```

In the above example, **class keyword indicates that you are creating a class followed by the name of the class** (Dog in this case).

## Class Objects
An Object is an instance of a Class. A class is like a blueprint while an instance is a copy of the class with actual values. It’s not an idea anymore, it’s an actual dog, like a dog of breed pug who’s seven years old. You can have many dogs to create many different instances, but without the class as a guide, you would be lost, not knowing what information is required.

An object consists of :

**State** : It is represented by attributes of an object. It also reflects the properties of an object.

**Behavior** : It is represented by methods of an object. It also reflects the response of an object with other objects.

**Identity** : It gives a unique name to an object and enables one object to interact with other objects.
![](https://media.geeksforgeeks.org/wp-content/uploads/Blank-Diagram-Page-1-5.png)

**Declaring Objects (Also called instantiating a class)**

When an object of a class is created, the class is said to be instantiated. All the instances share the attributes and the behavior of the class. But the values of those attributes, i.e. the state are unique for each object. A single class may have any number of instances.

Example:
![](https://media.geeksforgeeks.org/wp-content/uploads/Blank-Diagram-Page-1-3.png)

### Declaring an object 
In the bellow example, an object is created which is basically a dog named Rodger. This class only has two class attributes that tell us that Rodger is a dog and a mammal.


```python
# Python program to
# demonstrate instantiating
# a class


class Dog:

    # A simple class
    # attribute
    attr1 = "mamal"
    attr2 = "dog"

    # A sample method
    def fun(self):
        print("I'm a", self.attr1)
        print("I'm a", self.attr2)


# Driver code
# Object instantiation
Rodger = Dog()

# Accessing class attributes
# and method through objects
print(Rodger.attr1)
Rodger.fun()
```

    mamal
    I'm a mamal
    I'm a dog
    

## The self
1. Class methods must have an extra first parameter in method definition. We do not give a value for this parameter when we call the method, Python provides it.
2. If we have a method which takes no arguments, then we still have to have one argument.
3. This is similar to this pointer in C++ and this reference in Java.

When we call a method of this object as **myobject.method(arg1, arg2)**, this is automatically converted by Python into **MyClass.method(myobject, arg1, arg2)** – this is all the special self is about.

## __init__ method
A constructor also contains a collection of statements(i.e. instructions) that are executed at the time of Object creation. It is run as soon as an object of a class is instantiated. The method is useful to do any initialization you want to do with your object.


```python
# A Sample class with init method
class Person:

    # _init_ method or constructor
    def __init__(self, name):
        self.name = name

    # Sample Method
    def say_hi(self):
        print('Hello, my name is', self.name)


p = Person('Nikhil')
p.say_hi()
```

    Hello, my name is Nikhil
    

## Class and Instance Variables
Instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class. Instance variables are variables whose value is assigned inside a constructor or method with self whereas class variables are variables whose value is assigned in the class.

Defining instance varibale using constructor.


```python
# Python program to show that the variables with a value
# assigned in the class declaration, are class variables and
# variables inside methods and constructors are instance
# variables.


# Class for Dog
class Dog:

    # Class Variable
    animal = 'dog'

    # The init method or constructor
    def __init__(self, breed, color):

        # Instance Variable
        self.breed = breed
        self.color = color


# Objects of Dog class
Rodger = Dog("Pug", "brown")
Buzo = Dog("Bulldog", "black")

print('Rodger details:')
print('Rodger is a', Rodger.animal)
print('Breed: ', Rodger.breed)
print('Color: ', Rodger.color)

print('\nBuzo details:')
print('Buzo is a', Buzo.animal)
print('Breed: ', Buzo.breed)
print('Color: ', Buzo.color)

# Class variables can be accessed using class
# name also
print("\nAccessing class variable using class name")
print(Dog.animal)
```

    Rodger details:
    Rodger is a dog
    Breed:  Pug
    Color:  brown
    
    Buzo details:
    Buzo is a dog
    Breed:  Bulldog
    Color:  black
    
    Accessing class variable using class name
    dog
    

**Defining instance variable using the normal method.**


```python
# Python program to show that we can create
# instance variables inside methods


# Class for Dog
class Dog:

    # Class Variable
    animal = 'dog'

    # The init method or constructor
    def __init__(self, breed):

        # Instance Variable
        self.breed = breed

    # Adds an instance variable
    def setColor(self, color):
        self.color = color

    # Retrieves instance variable
    def getColor(self):
        return self.color


# Driver Code
Rodger = Dog("pug")
Rodger.setColor("brown")
print(Rodger.getColor())
```

    brown
    

                                            ****Part-1****
                                            *****END*****
